<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>Kind Predicates Revisited</title>
<link href="../docs-assets/Breadcrumbs.css" rel="stylesheet" rev="stylesheet" type="text/css">
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">

<link href="../docs-assets/Contents.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Progress.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Navigation.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Fonts.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Base.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script>
function togglePopup(material_id) {
  var popup = document.getElementById(material_id);
  popup.classList.toggle("show");
}
</script>

<link href="../docs-assets/Popups.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script>
MathJax = {
	tex: {
		inlineMath: '$', '$'], ['\\(', '\\)'
	},
	svg: {
		fontCache: 'global'
	}
};
</script>
<script type="text/javascript" id="MathJax-script" async
	src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>

<link href="../docs-assets/Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
		
	</head>
	<body class="commentary-font">
		<nav role="navigation">
		<h1><a href="../overview/index.html"><img src="../docs-assets/Inform.png" height=72> </a></h1>
<ul><li><a href="../overview/index.html">home</a></li>
</ul><h2>Compiler</h2><ul>
<li><a href="../structure/structure.html">structure</a></li>
<li><a href="../inbuildn/inbuildn.html">inbuild</a></li>
<li><a href="../inform7n/inform7n.html">inform7</a></li>
<li><a href="../intern/intern.html">inter</a></li>
<li><a href="../services/services.html">services</a></li>
<li><a href="../secrets/secrets.html">secrets</a></li>
</ul><h2>Other Tools</h2><ul>
<li><a href="../inblorbn/inblorbn.html">inblorb</a></li>
<li><a href="../inform6/inform6.html">inform6</a></li>
<li><a href="../inpolicyn/inpolicyn.html">inpolicy</a></li>
</ul><h2>Resources</h2><ul>
<li><a href="../extensions/extensions.html">extensions</a></li>
<li><a href="../kits/kits.html">kits</a></li>
</ul><h2>Repository</h2><ul>
<li><a href="https://github.com/ganelson/inform"><img src="../docs-assets/github.png" height=0> github</a></li>
</ul><h2>Related Projects</h2><ul>
<li><a href="https://github.com/ganelson/inweb"><img src="../docs-assets/github.png" height=0> inweb</a></li>
<li><a href="https://github.com/ganelson/intest"><img src="../docs-assets/github.png" height=0> intest</a></li>
</ul>
		</nav>
		<main role="main">
		<!-- Weave of 'Kind Predicates Revisited' generated by inweb -->
<div class="breadcrumbs">
    <ul class="crumbs"><li><a href="../overview/index.html">Home</a></li><li><a href="../inform7n/inform7n.html">Inform7</a></li><li><a href="index.html">assertions</a></li><li><a href="index.html#8">Chapter 8: Predicates</a></li><li><b>Kind Predicates Revisited</b></li></ul></div>
<p class="purpose">To define how the kind predicates behave in the Inform language.</p>

<p class="commentary firstcommentary"><a id="SP1" class="paragraph-anchor"></a><b>&#167;1. </b>Recall that for every kind <span class="extract"><span class="extract-syntax">K</span></span> the <a href="../calculus-module/index.html" class="internal">calculus</a> module makes a built-in
unary predicate <span class="extract"><span class="extract-syntax">kind=K(t)</span></span>, which is true if and only if <span class="extract"><span class="extract-syntax">t</span></span> has kind <span class="extract"><span class="extract-syntax">K</span></span>.
See <a href="../calculus-module/2-kp.html" class="internal">Kind Predicates (in calculus)</a> for details.
</p>

<p class="commentary">In this section, we give this family of UPs the necessary method calls to
be asserted and compiled from.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">KindPredicatesRevisited::start</span><button class="popup" onclick="togglePopup('usagePopup1')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup1">Usage of <span class="code-font"><span class="function-syntax">KindPredicatesRevisited::start</span></span>:<br/>Assertions Module - <a href="1-am.html#SP2">&#167;2</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">void</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">METHOD_ADD</span><span class="plain-syntax">(</span><span class="identifier-syntax">kind_up_family</span><span class="plain-syntax">, </span><span class="identifier-syntax">TYPECHECK_UPF_MTID</span><span class="plain-syntax">, </span><a href="8-kpr.html#SP2" class="function-link"><span class="function-syntax">KindPredicatesRevisited::typecheck</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">METHOD_ADD</span><span class="plain-syntax">(</span><span class="identifier-syntax">kind_up_family</span><span class="plain-syntax">, </span><span class="identifier-syntax">ASSERT_UPF_MTID</span><span class="plain-syntax">, </span><a href="8-kpr.html#SP3" class="function-link"><span class="function-syntax">KindPredicatesRevisited::assert</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">METHOD_ADD</span><span class="plain-syntax">(</span><span class="identifier-syntax">kind_up_family</span><span class="plain-syntax">, </span><span class="identifier-syntax">SCHEMA_UPF_MTID</span><span class="plain-syntax">, </span><a href="8-kpr.html#SP4" class="function-link"><span class="function-syntax">KindPredicatesRevisited::get_schema</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP2" class="paragraph-anchor"></a><b>&#167;2. </b>We will reject any "kind" applied to a constant if it necessarily fails &mdash;
even when the sense of the proposition is arguably correct. For example:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="constant-syntax">1</span><span class="plain-syntax">. </span><span class="constant-syntax">100</span><span class="plain-syntax"> </span><span class="identifier-syntax">is</span><span class="plain-syntax"> </span><span class="identifier-syntax">not</span><span class="plain-syntax"> </span><span class="identifier-syntax">a</span><span class="plain-syntax"> </span><span class="identifier-syntax">text</span>
<span class="plain-syntax">    &lt;&lt; </span><span class="identifier-syntax">NOT</span><span class="plain-syntax">&lt; </span><span class="identifier-syntax">text</span><span class="plain-syntax">(</span><span class="character-syntax">'100'</span><span class="plain-syntax">) </span><span class="identifier-syntax">NOT</span><span class="plain-syntax">&gt; &gt;&gt;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Failed:</span><span class="plain-syntax"> </span><span class="identifier-syntax">proposition</span><span class="plain-syntax"> </span><span class="identifier-syntax">would</span><span class="plain-syntax"> </span><span class="identifier-syntax">not</span><span class="plain-syntax"> </span><span class="identifier-syntax">type</span><span class="plain-syntax">-</span><span class="identifier-syntax">check</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Term</span><span class="plain-syntax"> </span><span class="character-syntax">'100'</span><span class="plain-syntax"> </span><span class="identifier-syntax">is</span><span class="plain-syntax"> </span><span class="identifier-syntax">number</span><span class="plain-syntax"> </span><span class="identifier-syntax">not</span><span class="plain-syntax"> </span><span class="identifier-syntax">text</span>
</pre>
<p class="commentary">"100 is not a number" would pass, on the other hand. It is obviously false,
but not meaningless.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">KindPredicatesRevisited::typecheck</span><button class="popup" onclick="togglePopup('usagePopup2')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup2">Usage of <span class="code-font"><span class="function-syntax">KindPredicatesRevisited::typecheck</span></span>:<br/><a href="8-kpr.html#SP1">&#167;1</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">up_family</span><span class="plain-syntax"> *</span><span class="identifier-syntax">self</span><span class="plain-syntax">, </span><span class="identifier-syntax">unary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">up</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">pcalc_prop</span><span class="plain-syntax"> *</span><span class="identifier-syntax">prop</span><span class="plain-syntax">, </span><span class="identifier-syntax">variable_type_assignment</span><span class="plain-syntax"> *</span><span class="identifier-syntax">vta</span><span class="plain-syntax">, </span><span class="identifier-syntax">tc_problem_kit</span><span class="plain-syntax"> *</span><span class="identifier-syntax">tck</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">need_to_find</span><span class="plain-syntax"> = </span><span class="identifier-syntax">up</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">assert_kind</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Kinds::Behaviour::is_object</span><span class="plain-syntax">(</span><span class="identifier-syntax">need_to_find</span><span class="plain-syntax">)) </span><span class="identifier-syntax">need_to_find</span><span class="plain-syntax"> = </span><span class="identifier-syntax">K_object</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">actually_find</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TypecheckPropositions::kind_of_term</span><span class="plain-syntax">(&amp;(</span><span class="identifier-syntax">prop</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">terms</span><span class="plain-syntax">[0]), </span><span class="identifier-syntax">vta</span><span class="plain-syntax">, </span><span class="identifier-syntax">tck</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Kinds::compatible</span><span class="plain-syntax">(</span><span class="identifier-syntax">actually_find</span><span class="plain-syntax">, </span><span class="identifier-syntax">need_to_find</span><span class="plain-syntax">) == </span><span class="identifier-syntax">NEVER_MATCH</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">tck</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">log_to_I6_text</span><span class="plain-syntax">)</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">LOG</span><span class="plain-syntax">(</span><span class="string-syntax">"Term $0 is %u not %u\n"</span><span class="plain-syntax">, &amp;(</span><span class="identifier-syntax">prop</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">terms</span><span class="plain-syntax">[0]), </span><span class="identifier-syntax">actually_find</span><span class="plain-syntax">, </span><span class="identifier-syntax">need_to_find</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">TypecheckPropositions::issue_kind_typecheck_error</span><span class="plain-syntax">(</span><span class="identifier-syntax">actually_find</span><span class="plain-syntax">, </span><span class="identifier-syntax">need_to_find</span><span class="plain-syntax">, </span><span class="identifier-syntax">tck</span><span class="plain-syntax">, </span><span class="identifier-syntax">prop</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NEVER_MATCH</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">ALWAYS_MATCH</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP3" class="paragraph-anchor"></a><b>&#167;3. </b>Note that we never assert the kind of non-objects. Typechecking won't allow such
an atom to exist unless it states something already true, so there is no need.
</p>

<p class="commentary">The problem message here is really quite hard to generate, because the
A-parser usually gets there first. "There is a banana which is something which
is not a door." will fall through here, but it isn't exactly an everyday
sentence.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">KindPredicatesRevisited::assert</span><button class="popup" onclick="togglePopup('usagePopup3')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup3">Usage of <span class="code-font"><span class="function-syntax">KindPredicatesRevisited::assert</span></span>:<br/><a href="8-kpr.html#SP1">&#167;1</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">up_family</span><span class="plain-syntax"> *</span><span class="identifier-syntax">self</span><span class="plain-syntax">, </span><span class="identifier-syntax">unary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">up</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">now_negated</span><span class="plain-syntax">, </span><span class="identifier-syntax">pcalc_prop</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pl</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">now_negated</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_CantAssertNonKind</span><span class="plain-syntax">),</span>
<span class="plain-syntax">            </span><span class="string-syntax">"that seems to say what kind something doesn't have"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="string-syntax">"which is too vague. You must say what kind it does have."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">subj</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Assert::subject_of_term</span><span class="plain-syntax">(</span><span class="identifier-syntax">pl</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">terms</span><span class="plain-syntax">[0]);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">ox</span><span class="plain-syntax"> = </span><span class="identifier-syntax">InstanceSubjects::to_object_instance</span><span class="plain-syntax">(</span><span class="identifier-syntax">subj</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">ox</span><span class="plain-syntax">) </span><span class="identifier-syntax">Instances::set_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">ox</span><span class="plain-syntax">, </span><span class="identifier-syntax">up</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">assert_kind</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">K</span><span class="plain-syntax"> = </span><span class="identifier-syntax">KindSubjects::to_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">subj</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">K</span><span class="plain-syntax">) </span><span class="identifier-syntax">Kinds::make_subkind</span><span class="plain-syntax">(</span><span class="identifier-syntax">K</span><span class="plain-syntax">, </span><span class="identifier-syntax">up</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">assert_kind</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP4" class="paragraph-anchor"></a><b>&#167;4. </b>In any type-checked proposition, a "kind" predicate can only exist where it is
always at least sometimes true. In particular, if \(K\) is a kind of value, then
the atom \(K(v)\) can only exist where \(v\) is of that kind of value, so that the
atom is always true when tested. But if \(K\) is a kind of object, then \(K(O)\)
may occur in the proposition for any object \(O\), where \(O\) need not belong
to \(K\) at all: so there is something substantive to check, which we do using
the I6 <span class="extract"><span class="extract-syntax">ofclass</span></span> operator.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">suppress_C14CantChangeKind</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">KindPredicatesRevisited::get_schema</span><button class="popup" onclick="togglePopup('usagePopup4')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup4">Usage of <span class="code-font"><span class="function-syntax">KindPredicatesRevisited::get_schema</span></span>:<br/><a href="8-kpr.html#SP1">&#167;1</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">up_family</span><span class="plain-syntax"> *</span><span class="identifier-syntax">self</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">task</span><span class="plain-syntax">, </span><span class="identifier-syntax">unary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">up</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">annotated_i6_schema</span><span class="plain-syntax"> *</span><span class="identifier-syntax">asch</span><span class="plain-syntax">, </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">K</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">switch</span><span class="plain-syntax">(</span><span class="identifier-syntax">task</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">TEST_ATOM_TASK:</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Kinds::Behaviour::is_subkind_of_object</span><span class="plain-syntax">(</span><span class="identifier-syntax">up</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">assert_kind</span><span class="plain-syntax">))</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Calculus::Schemas::modify</span><span class="plain-syntax">(</span><span class="identifier-syntax">asch</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">schema</span><span class="plain-syntax">, </span><span class="string-syntax">"*1 ofclass %n"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">RTKindDeclarations::iname</span><span class="plain-syntax">(</span><span class="identifier-syntax">up</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">assert_kind</span><span class="plain-syntax">));</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">                </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">Kinds::get_construct</span><span class="plain-syntax">(</span><span class="identifier-syntax">up</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">assert_kind</span><span class="plain-syntax">) == </span><span class="identifier-syntax">CON_list_of</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">                    (</span><span class="identifier-syntax">problem_count</span><span class="plain-syntax"> == </span><span class="constant-syntax">0</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">EK</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Kinds::unary_construction_material</span><span class="plain-syntax">(</span><span class="identifier-syntax">up</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">assert_kind</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Kinds::Behaviour::is_subkind_of_object</span><span class="plain-syntax">(</span><span class="identifier-syntax">EK</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">                        </span><span class="identifier-syntax">Problems::quote_source</span><span class="plain-syntax">(1, </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                        </span><span class="identifier-syntax">Problems::quote_kind</span><span class="plain-syntax">(2, </span><span class="identifier-syntax">up</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">assert_kind</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                        </span><span class="identifier-syntax">StandardProblems::handmade_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(),</span>
<span class="plain-syntax">                            </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_CantCheckListContents</span><span class="plain-syntax">));</span>
<span class="plain-syntax">                        </span><span class="identifier-syntax">Problems::issue_problem_segment</span><span class="plain-syntax">(</span>
<span class="plain-syntax">                            </span><span class="string-syntax">"In %1, you use a list which might or might not match a "</span>
<span class="plain-syntax">                            </span><span class="string-syntax">"definition requiring %2. But there's no efficient way to "</span>
<span class="plain-syntax">                            </span><span class="string-syntax">"tell during play whether the list actually contains that, "</span>
<span class="plain-syntax">                            </span><span class="string-syntax">"without laboriously checking every entry. Because "</span>
<span class="plain-syntax">                            </span><span class="string-syntax">"in general this would be a bad idea, this usage is "</span>
<span class="plain-syntax">                            </span><span class="string-syntax">"not allowed."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                        </span><span class="identifier-syntax">Problems::issue_problem_end</span><span class="plain-syntax">();</span>
<span class="plain-syntax">                    }</span>
<span class="plain-syntax">                }</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">Calculus::Schemas::modify</span><span class="plain-syntax">(</span><span class="identifier-syntax">asch</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">schema</span><span class="plain-syntax">, </span><span class="string-syntax">"true"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">NOW_ATOM_TRUE_TASK:</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">NOW_ATOM_FALSE_TASK:</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">suppress_C14CantChangeKind</span><span class="plain-syntax"> == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(),</span>
<span class="plain-syntax">                    </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_CantChangeKind</span><span class="plain-syntax">),</span>
<span class="plain-syntax">                    </span><span class="string-syntax">"the kind of something is fixed"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                    </span><span class="string-syntax">"and cannot be changed during play with a 'now'."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">asch</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">schema</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="identifier-syntax">Calculus::Schemas::modify</span><span class="plain-syntax">(</span><span class="identifier-syntax">asch</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">schema</span><span class="plain-syntax">, </span><span class="string-syntax">" "</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>
</pre>
<nav role="progress"><div class="progresscontainer">
    <ul class="progressbar"><li class="progressprev"><a href="7-eqt.html">&#10094;</a></li><li class="progresschapter"><a href="P-wtmd.html">P</a></li><li class="progresschapter"><a href="1-am.html">1</a></li><li class="progresschapter"><a href="2-bv.html">2</a></li><li class="progresschapter"><a href="3-dlr.html">3</a></li><li class="progresschapter"><a href="4-nr.html">4</a></li><li class="progresschapter"><a href="5-id.html">5</a></li><li class="progresschapter"><a href="6-rls.html">6</a></li><li class="progresschapter"><a href="7-tc.html">7</a></li><li class="progresscurrentchapter">8</li><li class="progresscurrent">kpr</li><li class="progresssection"><a href="8-tap.html">tap</a></li><li class="progresssection"><a href="8-tcp.html">tcp</a></li><li class="progresssection"><a href="8-terr.html">terr</a></li><li class="progresssection"><a href="8-qr.html">qr</a></li><li class="progresssection"><a href="8-tur.html">tur</a></li><li class="progresssection"><a href="8-er.html">er</a></li><li class="progresssection"><a href="8-lr.html">lr</a></li><li class="progresssection"><a href="8-aa.html">aa</a></li><li class="progresssection"><a href="8-am.html">am</a></li><li class="progresssection"><a href="8-amd.html">amd</a></li><li class="progresssection"><a href="8-abp.html">abp</a></li><li class="progresssection"><a href="8-abc.html">abc</a></li><li class="progresssection"><a href="8-abif.html">abif</a></li><li class="progresssection"><a href="8-abic.html">abic</a></li><li class="progresssection"><a href="8-cu.html">cu</a></li><li class="progressnext"><a href="8-tap.html">&#10095;</a></li></ul></div>
</nav><!-- End of weave -->

		</main>
	</body>
</html>

