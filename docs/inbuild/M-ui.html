<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>Using Inbuild</title>
<link href="../docs-assets/Breadcrumbs.css" rel="stylesheet" rev="stylesheet" type="text/css">
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">

<link href="../docs-assets/Contents.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Progress.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Navigation.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Fonts.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Base.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script src="http://code.jquery.com/jquery-1.12.4.min.js"
	integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>

<script src="../docs-assets/Bigfoot.js"></script>
<link href="../docs-assets/Bigfoot.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/ConsoleText-Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
		
	</head>
	<body class="commentary-font">
		<nav role="navigation">
		<h1><a href="../index.html"><img src="../docs-assets/Inform.png" height=72> </a></h1>
<ul><li><a href="../index.html">home</a></li>
</ul><h2>Compiler</h2><ul>
<li><a href="../structure.html">structure</a></li>
<li><a href="../inbuildn.html">inbuild</a></li>
<li><a href="../inform7n.html">inform7</a></li>
<li><a href="../intern.html">inter</a></li>
<li><a href="../services.html">services</a></li>
<li><a href="../secrets.html">secrets</a></li>
</ul><h2>Other Tools</h2><ul>
<li><a href="../inblorbn.html">inblorb</a></li>
<li><a href="../inform6.html">inform6</a></li>
<li><a href="../inpolicyn.html">inpolicy</a></li>
</ul><h2>Resources</h2><ul>
<li><a href="../extensions.html">extensions</a></li>
<li><a href="../kits.html">kits</a></li>
</ul><h2>Repository</h2><ul>
<li><a href="https://github.com/ganelson/inform"><img src="../docs-assets/github.png" height=0> github</a></li>
</ul><h2>Related Projects</h2><ul>
<li><a href="https://github.com/ganelson/inweb"><img src="../docs-assets/github.png" height=0> inweb</a></li>
<li><a href="https://github.com/ganelson/intest"><img src="../docs-assets/github.png" height=0> intest</a></li>
</ul>
		</nav>
		<main role="main">
		<!-- Weave of 'Using Inbuild' generated by inweb -->
<div class="breadcrumbs">
    <ul class="crumbs"><li><a href="../index.html">Home</a></li><li><a href="index.html">inbuild</a></li><li><a href="index.html#M">Manual</a></li><li><b>Using Inbuild</b></li></ul></div>
<p class="purpose">An introduction to the use of Inbuild on the command line.</p>

<ul class="toc"><li><a href="M-ui.html#SP1">&#167;1. What Inbuild is</a></li><li><a href="M-ui.html#SP2">&#167;2. Installation</a></li><li><a href="M-ui.html#SP3">&#167;3. Basic concepts</a></li><li><a href="M-ui.html#SP5">&#167;5. Graphs</a></li><li><a href="M-ui.html#SP11">&#167;11. Building</a></li><li><a href="M-ui.html#SP13">&#167;13. Specifying what to act on</a></li><li><a href="M-ui.html#SP15">&#167;15. Nests and searches</a></li><li><a href="M-ui.html#SP18">&#167;18. Copy, sync and archive</a></li></ul><hr class="tocbar">

<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP1" class="paragraph-anchor"></a><b>&#167;1. What Inbuild is.</b>  Inbuild is a rudimentary build and package manager for the Inform tools.
It consists of a large part of the front end of the Inform 7 compiler,
together with a command-line interface to access its functions. Because
it doesn't contain the middle or back ends of Inform 7, it cannot itself
compile Inform projects. But it can issue shell commands which have
this effect. When used that way, it's a little like the traditional Unix
build tool <code>make</code>.</p>
<p>It can also be used in <code>make</code> scripts itself. Inbuild returns an exit code
of 0 if successful, or else it throws errors to <code>stderr</code> and returns 1
if unsuccessful.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP2" class="paragraph-anchor"></a><b>&#167;2. Installation.</b>  When it runs, Inbuild needs to know where it is installed in the file
system. There is no completely foolproof, cross-platform way to know this
(on some Unixes, a program cannot determine its own location), so Inbuild
decides by the following set of rules:</p>
<ul>
<li>If the user, at the command line, specified <code>-at P</code>, for some path
<code>P</code>, then we use that.</li>
<li>Otherwise, if the host operating system can indeed tell us where the
executable is, we use that. This is currently implemented only on MacOS,
Windows and Linux.</li>
<li>Otherwise, if the environment variable <code>$INBUILD_PATH</code> exists and is
non-empty, we use that.</li>
<li>And if all else fails, we assume that the location is <code>inbuild</code>, with
respect to the current working directory.</li>
</ul>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP3" class="paragraph-anchor"></a><b>&#167;3. Basic concepts.</b>  Inbuild manages &quot;copies&quot;. A copy is an instance in the file system of an
asset like an Inform project, an extension, a kit of Inter code, and so on.
Those categories are called &quot;genres&quot;. Any given copy will be a copy of
what is called an &quot;edition&quot;, which in turn is a version of a &quot;work&quot;.</p>
<p>For example, perhaps the user has two copies of version 3 of the extension
Locksmith by Emily Short, in different places in the file system, and also
a further copy of version 4. These are three different &quot;copies&quot;, but only two
different &quot;editions&quot;, and all are of the same &quot;work&quot;. A work -- in this case,
Locksmith by Emily Short -- is identified by its title, author name and
genre -- in this case, an Inform extension.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP4" class="paragraph-anchor"></a><b>&#167;4. </b>  Inbuild has a plethora of command-line options, but at its most basic, the
user should specify what to do and then give a list of things to do it to.
For example, here we run <code>-inspect</code> on a single copy, and get a one-line
description of what it is:</p>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">inbuild/Tangled/inbuild</span><span class="ConsoleText-identifier-syntax"> -inspect</span><span class="ConsoleText-plain-syntax"> 'inform7/Internal/Extensions/Emily Short/Locksmith.i7x'</span>
<span class="ConsoleText-plain-syntax">    extension: Locksmith by Emily Short v12 in directory inform7/Internal/Extensions/Emily Short</span>
</pre>
<div class="lsmarkdown">
<p>This is reassuring -- the file which looks as if it ought to be a copy of
Locksmith actually is. Inbuild always looks at the contents of something,
and doesn't trust its location as any indication of what it is. For
example:</p>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">inbuild/Tangled/inbuild</span><span class="ConsoleText-identifier-syntax"> -inspect</span><span class="ConsoleText-plain-syntax"> junk/Mystery.i7x</span>
<span class="ConsoleText-plain-syntax">    extension: Complex Listing by Emily Short v9 in directory junk.</span>
</pre>
<div class="lsmarkdown">
<p>If Inbuild can see that something is damaged in some way, it will report that.
For example,</p>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    extension: Skeleton Keys by Emily Short - 1 error</span>
<span class="ConsoleText-plain-syntax">        1. extension misworded: the opening line does not end 'begin(s) here'</span>
</pre>
<div class="lsmarkdown">
<p>Only superficial problems can be spotted so far in advance of actually using
the software, but it's still helpful.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP5" class="paragraph-anchor"></a><b>&#167;5. Graphs.</b>  More ambitiously, we can look at the &quot;graph&quot; of a copy.</p>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">inbuild/Tangled/inbuild</span><span class="ConsoleText-identifier-syntax"> -graph</span><span class="ConsoleText-plain-syntax"> 'Basic Help Menu.i7x'</span>
<span class="ConsoleText-plain-syntax">    [c0] Basic Help Menu by Emily Short</span>
<span class="ConsoleText-plain-syntax">      --use---&gt; [c26] Menus by Emily Short v3</span>
<span class="ConsoleText-plain-syntax">        --use---&gt; [c34] Basic Screen Effects by Emily Short v8</span>
</pre>
<div class="lsmarkdown">
<p>The graph begins at the copy we asked for, and then continues through arrows
to other copies. It gives a systematic answer to the question &quot;how do I
build or use this?&quot;. There are two kinds of arrows, use arrows and build
arrows. A use arrow from A to B means that you need to have B installed
in order to be able to use A. The above example, then, tells us that we need
Menus in order to use Basic Help Menu, and we need Basic Screen Effects in
order to use Menus.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP6" class="paragraph-anchor"></a><b>&#167;6. </b>  Now suppose we have an Inform project called <code>Menu Time.inform</code>, whose
source text is as follows:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">Include</span><span class="plain-syntax"> </span><span class="identifier-syntax">Basic</span><span class="plain-syntax"> </span><span class="identifier-syntax">Help</span><span class="plain-syntax"> </span><span class="identifier-syntax">Menu</span><span class="plain-syntax"> </span><span class="identifier-syntax">by</span><span class="plain-syntax"> </span><span class="identifier-syntax">Emily</span><span class="plain-syntax"> </span><span class="identifier-syntax">Short</span><span class="plain-syntax">.</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">The</span><span class="plain-syntax"> </span><span class="identifier-syntax">French</span><span class="plain-syntax"> </span><span class="identifier-syntax">Laundry</span><span class="plain-syntax"> </span><span class="identifier-syntax">is</span><span class="plain-syntax"> </span><span class="identifier-syntax">a</span><span class="plain-syntax"> </span><span class="identifier-syntax">room</span><span class="plain-syntax">.</span>
</pre>
<div class="lsmarkdown">
<p>Once again, we can inspect this:</p>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">inbuild/Tangled/inbuild</span><span class="ConsoleText-identifier-syntax"> -inspect</span><span class="ConsoleText-plain-syntax"> 'Menu Time.inform'</span>
<span class="ConsoleText-plain-syntax">    projectbundle: Menu Time.inform at path Menu Time.inform</span>
</pre>
<div class="lsmarkdown">
<p>We can also use <code>-graph</code>, but the output from this is surprisingly long,
because an innocent-looking source text like the above depends on many other
resources.</p>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    [f59] Menu Time.inform/Build/output.ulx</span>
<span class="ConsoleText-plain-syntax">      --build-&gt; [f58] Menu Time.inform/Build/auto.inf</span>
<span class="ConsoleText-plain-syntax">        --build-&gt; [f57] Menu Time.inform/Build/auto.inf</span>
<span class="ConsoleText-plain-syntax">          --build-&gt; [c0] Menu Time.inform</span>
<span class="ConsoleText-plain-syntax">            --build-&gt; [c53] Basic Help Menu by Emily Short</span>
<span class="ConsoleText-plain-syntax">              --use---&gt; [c47] Menus by Emily Short v3</span>
<span class="ConsoleText-plain-syntax">                --use---&gt; [c55] Basic Screen Effects by Emily Short v8</span>
<span class="ConsoleText-plain-syntax">            --build-&gt; [f1] Menu Time.inform/Source/story.ni</span>
<span class="ConsoleText-plain-syntax">            --build-&gt; [c12] BasicInformKit</span>
</pre>
<div class="lsmarkdown">
<p>...and so on. What's going on here is that if the user wants to compile the
source text, that will (by default) mean making a story file in Glulx format,
called <code>output.ulx</code>, which sits inside the project bundle. So that is the top
node. Note that it is a &quot;file node&quot;, not a &quot;copy node&quot;, as we can see from the
<code>f</code> not <code>c</code> in its node number. This means that <code>output.ulx</code> is not a kind of
resource managed by Inbuild (like an extension, pr a project): it's just a
plain old file.</p>
<p>There's then a build arrow to another file called <code>auto.inf</code>. That's because
in order to build <code>output.ulx</code>, we first need <code>auto.inf</code> to exist. This is
a file in Inform 6 format. Something unexpected then happens: a further arrow
appears, and connects to another <code>auto.inf</code>. There aren't really two files
here: this is a device to capture the fact that generating <code>auto.inf</code> is a
two-stage process, with the intermediate results between the two stages
being held in memory rather than in a file. (These stages are, first,
converting I7 source text to inter code, and then code-generating that
inter code to I6.) Finally, though, we have a build arrow leading to the
place we might have expected to start: the <code>Menu Time.inform</code> project.</p>
<p>And that is where the graph branches outwards, because we need many
different resources in order to build <code>Menu Time.inform</code>. We finally see
that we need Basic Help Menu, and because that uses two other extensions
in turn, we'll need both of those as well. We need the actual file which
holds the source text inside the project bundle, <code>story.ni</code>. And then
we need various build-in extensions and kits, the first of which is
<code>BasicInformKit</code>, and that turns out to need lots of files to exist.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP7" class="paragraph-anchor"></a><b>&#167;7. </b>  The full <code>-graph</code> is not always what we want to see. Often all we really
want to know is: what do I need to use, or to build, something?</p>
<p>The command <code>-use-needs</code> applied to our example extension gives:</p>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    extension: Basic Help Menu by Emily Short</span>
<span class="ConsoleText-plain-syntax">      extension: Menus by Emily Short v3</span>
<span class="ConsoleText-plain-syntax">        extension: Basic Screen Effects by Emily Short v8</span>
</pre>
<div class="lsmarkdown">
<p>and applied to our example story gives just:</p>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    projectbundle: Menu Time.inform</span>
</pre>
<div class="lsmarkdown">
<p>That's because once Menu Time is built, nothing else is needed to use it.
On the other hand, <code>-build-needs</code> has the opposite effect. Applied to the
extension, we get:</p>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    extension: Basic Help Menu by Emily Short</span>
</pre>
<div class="lsmarkdown">
<p>because extensions need no building, so certainly nothing else is needed
to build them. But <code>-build-needs</code> on our story produces:</p>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    projectbundle: Menu Time.inform</span>
<span class="ConsoleText-plain-syntax">      extension: Basic Help Menu by Emily Short</span>
<span class="ConsoleText-plain-syntax">        extension: Menus by Emily Short v3</span>
<span class="ConsoleText-plain-syntax">          extension: Basic Screen Effects by Emily Short v8</span>
<span class="ConsoleText-plain-syntax">      kit: BasicInformKit</span>
<span class="ConsoleText-plain-syntax">        extension: Basic Inform by Graham Nelson v1</span>
<span class="ConsoleText-plain-syntax">        extension: English Language by Graham Nelson v1</span>
<span class="ConsoleText-plain-syntax">      kit: CommandParserKit</span>
<span class="ConsoleText-plain-syntax">        kit: WorldModelKit</span>
<span class="ConsoleText-plain-syntax">          extension: Standard Rules by Graham Nelson v6</span>
<span class="ConsoleText-plain-syntax">        extension: Standard Rules by Graham Nelson v6</span>
<span class="ConsoleText-plain-syntax">      language: English</span>
<span class="ConsoleText-plain-syntax">        kit: EnglishLanguageKit</span>
<span class="ConsoleText-plain-syntax">          extension: English Language by Graham Nelson v1</span>
</pre>
<div class="lsmarkdown">
<p>And there it is: six extensions, four kits and one natural language definition
are needed. Two of the extensions are listed twice: that's because they are
each needed for two different reasons.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP8" class="paragraph-anchor"></a><b>&#167;8. </b>  The version numbers listed above do not mean that only those exact versions
will do: they mean that this is (the best) version Inbuild has access to.
They're given because two different versions of the same extension might
make different choices about which other extensions to include. We can say
that version 3 of Menus wants to have Basic Screen Effects, but maybe someday
there will be a version 4 which doesn't need it.</p>
<p>Another issue to watch out for is that a copy may use different other copies
when compiled to different virtual machines. For example, an extension can
contain a heading of material &quot;for Glulx only&quot;, and that heading might
comtain a line which includes another extension X. If so, then we use X on
Glulx but not on other architectures. We can also flag material as being for
release only, or for debugging only.</p>
<p>Inbuild accepts the same command-line options as <code>inform7</code> does to specify
these: <code>-debug</code> for debugging features, <code>-release</code> for a release run, and
<code>-format=X</code> to select a virtual machine. (See the <code>inform7</code> documentation.)</p>
</div>
<p class="commentary firstcommentary"><a id="SP9" class="paragraph-anchor"></a><b>&#167;9. </b> </p>

<blockquote>
    <p>Include Xylophones by Jimmy Stewart.</p>
</blockquote>

<div class="lsmarkdown">
<p>Now suppose that the project asks for something impossible, with a line
such as:</p>
</div>
<div class="lsmarkdown">
<p>No such extension exists. If we look at the graph, or the <code>-build-needs</code> list
for the project, we see that it includes:</p>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    missing extension: Xylophones by Jimmy Stewart, any version will do</span>
</pre>
<blockquote>
    <p>Include version 6.2 of Xylophones by Jimmy Stewart.</p>
</blockquote>

<div class="lsmarkdown">
<p>If we had instead written:</p>
</div>
<div class="lsmarkdown">
<p>we would see:</p>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    missing extension: Xylophones by Jimmy Stewart, need version in range [6.2,7-A)</span>
</pre>
<div class="lsmarkdown">
<p>This slightly arcane mathematical notation means that Inform would accept any
version from 6.2 upwards, provided it still begins with a 6. This is a change
over pre-2020 versions of Inform, and has been brought about by the adoption
of the semantic version number standard.</p>
<p>Inbuild can list missing resources with <code>-use-missing</code> and <code>-build-missing</code>
respectively. At present, it has no means of fetching missing resources from
any central repository.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP10" class="paragraph-anchor"></a><b>&#167;10. </b>  Finally, <code>-build-locate</code> and <code>-use-locate</code> are identical to <code>-build-needs</code>
and <code>-use-needs</code>, except that they print a list of the file system paths at
which the relevant resources have been found. This can be useful if you're
managing a complex mass of extensions, and aren't sure (say) which actual copy
of Xylophones inbuild proposes to use, and from where.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP11" class="paragraph-anchor"></a><b>&#167;11. Building.</b>  The graph for a copy tells Inbuild not only what is necessary for a build,
but also how to perform that build.</p>
<p>As noted above, not everything needs building. Extensions do not, in particular,
so running <code>-build</code> on one will do nothing. Kits do need building: what this
does is to &quot;assimilate&quot; the Inform 6-notation source files inside the kit into
binary files of Inter, one for each possible architecture.</p>
<p>But building is mostly done with projects. If we run:</p>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">inbuild/Tangled/inbuild</span><span class="ConsoleText-identifier-syntax"> -build</span><span class="ConsoleText-plain-syntax"> Example.inform</span>
</pre>
<div class="lsmarkdown">
<p>then Inbuild will first build everything needed to build the Example story
file, including everything needed to use the things needed to build it, and
so on; and then will build Example itself. As with the Unix utility <code>make</code>,
this is an incremental process, and looks at the timestamps of files to see
which steps are needed and which are not. If all the kits needed by Example
are up to date, then the kits will not be rebuilt, and so on. If the same
project is built twice in a row, and nothing about it has changed since
the first time, the second <code>-build</code> does nothing.</p>
<p>Inbuild uses the graph to work out what needs to be done, and then issues
a series of shell commands to other Inform tools. If any of those commands
fail (returning a non-zero exit code) then the build process halts at once.</p>
<p>As noted above, the <code>-release</code> switch tells Inbuild that we want to go all
the way to a release of the project, not just a build. This makes a more
extensive graph, and is likely to mean that the final step followed by
Inbuild is a call to <code>inblorb</code>, the releasing tool for Inform.</p>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">inbuild/Tangled/inbuild</span><span class="ConsoleText-identifier-syntax"> -release -build</span><span class="ConsoleText-plain-syntax"> Example.inform</span>
</pre>
<div class="lsmarkdown">
<p>Using the <code>-rebuild</code> command performs a build in a way which isn't incremental:
timestamps of files are ignored and everything is remade from scratch.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP12" class="paragraph-anchor"></a><b>&#167;12. </b>  It takes a certain trust to just let Inbuild rip, and if you don't feel that
trust, adding the <code>-dry</code> switch causes shell commands to be printed out but
not actually executed -- a dry run. If you are debugging Inbuild, you may
also want to look at the copious output produced when <code>-build-trace</code> is used.
These are not commands: they simply modify the behaviour of <code>-build</code> and
<code>-rebuild</code>.</p>
<p>Inbuild uses a handful of standard Unix shell commands, but it also uses
<code>inform7</code>, <code>inform6</code>, <code>inblorb</code> and <code>inter</code>. To do that, it needs to know
where they are installed. By default, Inbuild assumes they are in the same
folder as Inbuild itself, side by side. If not, you can use <code>-tools P</code> to
specify path <code>P</code> as the home of the other Intools.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP13" class="paragraph-anchor"></a><b>&#167;13. Specifying what to act on.</b>  In all of the examples above, Inbuild is given just one copy to act on.
(That action may end up involving lots of other copies, but only one is
mentioned on the command line.) In fact it's legal to give a list of
copies to work on, one at a time, except that only one of those copies
can be an Inform project. Multiple extensions, or kits, are fine.</p>
<p>We can also tell Inbuild to work on everything it finds in a given directory
<code>D</code> using <code>-contents-of D</code>:</p>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">inbuild/Tangled/inbuild</span><span class="ConsoleText-identifier-syntax"> -inspect -contents-of</span><span class="ConsoleText-plain-syntax"> inform7/Internal/Inter</span>
<span class="ConsoleText-plain-syntax">    kit: EnglishLanguageKit at path inform7/Internal/Inter/EnglishLanguageKit</span>
<span class="ConsoleText-plain-syntax">    kit: CommandParserKit at path inform7/Internal/Inter/CommandParserKit</span>
<span class="ConsoleText-plain-syntax">    ...</span>
</pre>
<div class="lsmarkdown">
<p>For compatibility with the <code>inform7</code> command line syntax, we can also specify
the project target using <code>-project</code>:</p>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">inbuild/Tangled/inbuild</span><span class="ConsoleText-identifier-syntax"> -build -project</span><span class="ConsoleText-plain-syntax"> Example.inform</span>
</pre>
<div class="lsmarkdown">
<p>But this is quite unnecessary: the effect is the same as if <code>-project</code> had
been missed out.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP14" class="paragraph-anchor"></a><b>&#167;14. </b>  Listing filenames or pathnames of copies on the command line, or using the
<code>-contents-of D</code> switch, is only possible if we know where in the file system
these copies are; and sometimes we do not.</p>
<p>If we instead specify <code>-matching R</code>, where <code>R</code> is a list of requirements,
Inbuild will act on every copy it can find which matches that. For example,</p>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">inbuild/Tangled/inbuild</span><span class="ConsoleText-identifier-syntax"> -inspect -matching</span><span class="ConsoleText-plain-syntax"> 'genre=kit'</span>
</pre>
<div class="lsmarkdown">
<p>lists all the kits which Inbuild can see; and</p>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">inbuild/Tangled/inbuild</span><span class="ConsoleText-identifier-syntax"> -inspect -matching</span><span class="ConsoleText-plain-syntax"> 'genre=extension,author=Eric Eve'</span>
</pre>
<div class="lsmarkdown">
<p>lists all extensions by Eric Eve which Inbuild can see. The legal clauses to
specify are <code>title</code>, <code>author</code>, <code>genre</code> and <code>version</code>. Note that <code>version=5.1.1</code>
would match version numbers 5.1.1, 5.1.2, 5.2.0, etc., but not 6 or above:
again, this is following semver conventions. (Extensions giving their version
numbers in the old-fashioned format &quot;N/YYMMDD&quot; are read as if N.0.YYMMDD, with
the release date being treated as a patch number: see the Inform language
documentation for examples.)</p>
<p>To specify an explicit maximum and minimum version number, use <code>max</code> and <code>min</code>. For example:</p>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    -matching 'genre=extension,author=Emily Short,title=Locksmith,min=6.1-alpha.2,max=17.2'</span>
</pre>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP15" class="paragraph-anchor"></a><b>&#167;15. Nests and searches.</b>  When searching with <code>-matching R</code>, or indeed when running Inform and needing
to find certain resources, Inbuild looks inside what are called &quot;nests&quot;.</p>
<p>A nest is a directory with structured subdirectories, which correspond to
the genres of copies put into them. For example, in the standard distribution
of Inform as a command-line tool, the path <code>inform7/Internal</code> is a nest:
this contains the extensions, kits and so on which are built in to Inform
when it's used as an app.</p>
<p>Inbuild recognises the following subdirectories of a nest as significant:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">Templates</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Pipelines</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Inter</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Languages</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Extensions</span>
</pre>
<div class="lsmarkdown">
<p>Other subdirectories can also exist, and Inbuild ignores those. The above
five containers hold website templates (used by Inblorb), Inter pipelines,
kits, language definitions, and extensions. In the case of extensions, where
there may be very many in total, a further level of subdirectory is used
for the author's name. Thus:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">Extensions</span><span class="plain-syntax">/</span><span class="identifier-syntax">Emily</span><span class="plain-syntax"> </span><span class="identifier-syntax">Short</span><span class="plain-syntax">/</span><span class="identifier-syntax">Locksmith</span><span class="plain-syntax">.</span><span class="identifier-syntax">i7x</span>
</pre>
<div class="lsmarkdown">
<p>(In some early releases of Inform 7, it was legal for this file not to have
the <code>.i7x</code> extension: but now it is compulsory.)</p>
<p>As of 2020, nests can contain multiple versions of the same work. To do
this, they should have a filename (or pathname) which ends with <code>-vN</code>, where
<code>N</code> is semantic version number but with any dots replaced by underscores.
Thus, we can have e.g.:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">Extensions</span><span class="plain-syntax">/</span><span class="identifier-syntax">Emily</span><span class="plain-syntax"> </span><span class="identifier-syntax">Short</span><span class="plain-syntax">/</span><span class="identifier-syntax">Locksmith</span><span class="plain-syntax">-</span><span class="identifier-syntax">v3_2</span><span class="plain-syntax">.</span><span class="identifier-syntax">i7x</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Extensions</span><span class="plain-syntax">/</span><span class="identifier-syntax">Emily</span><span class="plain-syntax"> </span><span class="identifier-syntax">Short</span><span class="plain-syntax">/</span><span class="identifier-syntax">Locksmith</span><span class="plain-syntax">-</span><span class="identifier-syntax">v4_0_0</span><span class="plain-syntax">-</span><span class="identifier-syntax">prealpha_13</span><span class="plain-syntax">.</span><span class="identifier-syntax">i7x</span>
</pre>
<blockquote>
    <p>Include Locksmith by Emily Short.</p>
</blockquote>

<blockquote>
    <p>Include version 3 Locksmith by Emily Short.</p>
</blockquote>

<div class="lsmarkdown">
<p>co-existing side by side. If the user asks to</p>
</div>
<div class="lsmarkdown">
<p>then version <code>4.0.0-prealpha.13</code> will be chosen, as the one with highest
precedence in this nest (but see below for how Inbuild chooses between
versions in the same nest). But if the user asks for</p>
</div>
<div class="lsmarkdown">
<p>then version <code>3.2</code> is the winner, as the highest-numbered extension in the
nest with the right major version number (3).</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP16" class="paragraph-anchor"></a><b>&#167;16. </b>  In most runs of the Inform compiler, three nests are used: the &quot;internal&quot;
one, so-called, which holds built-in extensions and is read-only; the
&quot;external&quot; one, which will be somewhere outside of the Inform GUI app, and
will hold additional extensions downloaded by the user; and the Materials
folder for an Inform project, which is a nest all by itself.</p>
<p>Inbuild looks for these as follows:</p>
<ul>
<li><code>-internal N</code> tells Inbuild the path <code>N</code> for the internal nest; if this
is not given, the default is <code>inform7/Internal</code>.</li>
<li><code>-external N</code> tells Inbuild the path <code>N</code> for the external nest; if this
is not given, the default depends on the host operating system. For example,
on MacOS it will be <code>~/Library/Inform</code> (which is what the Inform GUI app
uses too if it is not sandboxed: if it is indeed sandboxed, then it will
have a deliberately obfuscated location which MacOS does not want tools
like ours to access externally).</li>
<li>The Materials nest is always the Materials folder associated with the
project Inbuild is working on; if it isn't working on a project, then this
nest is of course not present.</li>
</ul>
<p>In addition, extra nests can be specified with <code>-nest N</code>.</p>
</div>
<p class="commentary firstcommentary"><a id="SP17" class="paragraph-anchor"></a><b>&#167;17. </b> </p>

<blockquote>
    <p>Include Locksmith by Emily Short.</p>
</blockquote>

<blockquote>
    <p>Include version 4 of Locksmith by Emily Short.</p>
</blockquote>

<div class="lsmarkdown">
<p>When Inbuild searches for some resource needed by Inform -- let's continue
to use the Locksmith extension as an example -- it always has some range of
version numbers in mind: it will only accept a version in that range. (The
range can be unlimited, in which case any version is acceptable.)</p>
<p>This may well produce multiple results: as noted above, we might have multiple
copies of Locksmith around. Inbuild first reduces the list to just those
whose version lies in the acceptable range. It then applies the following
rules:</p>
<ul>
<li>A copy in the Materials nest takes precedence over all others.</li>
<li>Otherwise, all other copies take precedence over those in the
internal nest.</li>
<li>Otherwise, semantic version number rules are used to determine which
copy had precedence.</li>
</ul>
<p>Suppose the Materials folder for our project contains <code>Locksmith-v3_2.i7x</code>,
while the external folder contains <code>Locksmith-v3_3.i7x</code> and <code>Locksmith-v4.i7x</code>.
Then the sentence:</p>
</div>
<div class="lsmarkdown">
<p>would result in <code>Locksmith-v3_2.i7x</code> from Materials being used, even though
there's a later version in the external area: Materials always wins. But</p>
</div>
<div class="lsmarkdown">
<p>would use <code>Locksmith-v4.i7x</code> from the external area, because the copy in the
Materials folder doesn't qualify.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP18" class="paragraph-anchor"></a><b>&#167;18. Copy, sync and archive.</b>  Clerical work is generally best done automatically, and Inbuild offers some
useful filing commands.</p>
<p>The command <code>-copy-to N</code> makes a duplicate copy in the nest <code>N</code>. For example:</p>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">inbuild/Tangled/inbuild</span><span class="ConsoleText-identifier-syntax"> -inspect</span><span class="ConsoleText-plain-syntax"> junk/Mystery.i7x</span>
<span class="ConsoleText-plain-syntax">    extension: Complex Listing by Emily Short v9 in directory junk.</span>
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">inbuild/Tangled/inbuild</span><span class="ConsoleText-identifier-syntax"> -copy-to</span><span class="ConsoleText-plain-syntax"> MyNest junk/Mystery.i7x</span>
<span class="ConsoleText-plain-syntax">    cp -f 'junk/Mystery.i7x' 'MyNest/Extensions/Emily Short/Complex Listing-v9.i7x'</span>
</pre>
<div class="lsmarkdown">
<p>Note that Inbuild replies to the <code>-copy-to N</code> command by executing a shell
command to copy what is, in this case, a single file. As when building, the
<code>-dry</code> option puts Inbuild into dry-run mode, where it prints the commands it
would like to execute but doesn't execute them.</p>
<p>The command <code>-sync-to N</code> is similar, but will overwrite any existing copy
already in <code>N</code>, rather than producing an error if a collision occurs.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP19" class="paragraph-anchor"></a><b>&#167;19. </b>  If the version numbers are not wanted in the filenames which <code>-copy-to</code>
and <code>-sync-to</code> write to, set <code>-no-versions-in-filenames</code>:</p>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">inbuild/Tangled/inbuild</span><span class="ConsoleText-identifier-syntax"> -inspect</span><span class="ConsoleText-plain-syntax"> junk/Mystery.i7x</span>
<span class="ConsoleText-plain-syntax">    extension: Complex Listing by Emily Short v9 in directory junk.</span>
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">inbuild/Tangled/inbuild</span><span class="ConsoleText-identifier-syntax"> -no-versions-in-filenames -copy-to</span><span class="ConsoleText-plain-syntax"> MyNest junk/Mystery.i7x</span>
<span class="ConsoleText-plain-syntax">    cp -f 'junk/Mystery.i7x' 'MyNest/Extensions/Emily Short/Complex Listing.i7x'</span>
</pre>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP20" class="paragraph-anchor"></a><b>&#167;20. </b>  The <code>-archive-to N</code> command performs <code>-sync-to N</code> on any resource needed
to build the copy it is working on (with one exception, for technical reasons:
the configuration file telling Inform how to use the English natural language).</p>
<p>This is really only useful for Inform projects, and the abbreviated form
<code>-archive</code> performs <code>-archive-to</code> to the Materials folder for a project.
The net effect of this is that all extensions needed to build a story file
are gathered, with their correct versions, into the Materials folder; this
means that if the project and its Materials are moved to a different user's
computer, where a quite different set of extensions may be installed, then
the project will still work exactly as it originally did.</p>
</div>
<nav role="progress"><div class="progresscontainer">
    <ul class="progressbar"><li class="progressprevoff">&#10094;</li><li class="progresscurrentchapter">M</li><li class="progresscurrent">ui</li><li class="progresssection"><a href="M-agtk.html">agtk</a></li><li class="progresssection"><a href="M-agtlb.html">agtlb</a></li><li class="progresssection"><a href="M-agtpm.html">agtpm</a></li><li class="progresssection"><a href="M-agtr.html">agtr</a></li><li class="progresssection"><a href="M-rc.html">rc</a></li><li class="progresschapter"><a href="1-mn.html">1</a></li><li class="progressnext"><a href="M-agtk.html">&#10095;</a></li></ul></div>
</nav><!-- End of weave -->

		</main>
	</body>
</html>

