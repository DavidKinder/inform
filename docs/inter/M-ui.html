<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>Using Inter</title>
<link href="../docs-assets/Breadcrumbs.css" rel="stylesheet" rev="stylesheet" type="text/css">
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">

<link href="../docs-assets/Contents.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Progress.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Navigation.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Fonts.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Base.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script src="http://code.jquery.com/jquery-1.12.4.min.js"
	integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>

<script src="../docs-assets/Bigfoot.js"></script>
<link href="../docs-assets/Bigfoot.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/ConsoleText-Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
		
	</head>
	<body class="commentary-font">
		<nav role="navigation">
		<h1><a href="../index.html"><img src="../docs-assets/Inform.png" height=72> </a></h1>
<ul><li><a href="../index.html">home</a></li>
</ul><h2>Compiler</h2><ul>
<li><a href="../structure.html">structure</a></li>
<li><a href="../inbuildn.html">inbuild</a></li>
<li><a href="../inform7n.html">inform7</a></li>
<li><a href="../intern.html">inter</a></li>
<li><a href="../services.html">services</a></li>
<li><a href="../secrets.html">secrets</a></li>
</ul><h2>Other Tools</h2><ul>
<li><a href="../inblorbn.html">inblorb</a></li>
<li><a href="../inform6.html">inform6</a></li>
<li><a href="../inpolicyn.html">inpolicy</a></li>
</ul><h2>Resources</h2><ul>
<li><a href="../extensions.html">extensions</a></li>
<li><a href="../kits.html">kits</a></li>
</ul><h2>Repository</h2><ul>
<li><a href="https://github.com/ganelson/inform"><img src="../docs-assets/github.png" height=0> github</a></li>
</ul><h2>Related Projects</h2><ul>
<li><a href="https://github.com/ganelson/inweb"><img src="../docs-assets/github.png" height=0> inweb</a></li>
<li><a href="https://github.com/ganelson/intest"><img src="../docs-assets/github.png" height=0> intest</a></li>
</ul>
		</nav>
		<main role="main">
		<!-- Weave of 'Using Inter' generated by inweb -->
<div class="breadcrumbs">
    <ul class="crumbs"><li><a href="../index.html">Home</a></li><li><a href="index.html">inter</a></li><li><a href="index.html#M">Manual</a></li><li><b>Using Inter</b></li></ul></div>
<p class="purpose">Using Inter at the command line.</p>

<ul class="toc"><li><a href="M-ui.html#SP1">&#167;1. What Inter does</a></li><li><a href="M-ui.html#SP3">&#167;3. Verify only</a></li><li><a href="M-ui.html#SP4">&#167;4. Format conversion</a></li><li><a href="M-ui.html#SP5">&#167;5. Running a pipeline</a></li><li><a href="M-ui.html#SP9">&#167;9. Assimilation</a></li></ul><hr class="tocbar">

<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP1" class="paragraph-anchor"></a><b>&#167;1. What Inter does.</b>  &quot;Inter&quot; is the intermediate representation of a program used in the Inform
compiler toolchain. Most compilers have one of these: for example, Microsoft
compilers mostly use &quot;CIL&quot; (common intermediate language), while <code>gcc</code> uses
something called GIMPLE, and so on. See <a href="../bytecode-module/index.html" class="internal">bytecode</a> for a longer discussion
of what motivates the design of Inter.</p>
<p>The practical effect is that the back end of the Inform compiler deals only
with Inter code. This back end exists as part of the executable <a href="../inform7/index.html" class="internal">inform7</a>,
but also as a stand-alone program called <a href="index.html" class="internal">inter</a>, which comes with its
own command-line interface. Whereas <a href="../inform7/index.html" class="internal">inform7</a> has a specific task to perform
and uses Inter code only as a means to an end, <a href="index.html" class="internal">inter</a> is designed to be
as flexible as possible.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP2" class="paragraph-anchor"></a><b>&#167;2. </b>  Inter code can exist in memory, or in a human-readable text file, or in a
rapid-access binary file. The tool <a href="index.html" class="internal">inter</a> can convert between these formats:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">  </span><span class="element-syntax">textual</span><span class="plain-syntax">                                  </span><span class="element-syntax">textual</span>
<span class="plain-syntax">  </span><span class="element-syntax">inter</span><span class="plain-syntax">   ---+                       +---&gt; </span><span class="element-syntax">inter</span>
<span class="plain-syntax">              \                     /</span>
<span class="plain-syntax">               \                   /</span>
<span class="plain-syntax">                ----&gt;  </span><span class="element-syntax">memory</span><span class="plain-syntax">  ----</span>
<span class="plain-syntax">               /       </span><span class="element-syntax">inter</span><span class="plain-syntax">       \</span>
<span class="plain-syntax">  </span><span class="element-syntax">binary</span><span class="plain-syntax">      /                     \      </span><span class="element-syntax">binary</span>
<span class="plain-syntax">  </span><span class="element-syntax">inter</span><span class="plain-syntax">   ---+                       +---&gt; </span><span class="element-syntax">inter</span>
</pre>
<div class="lsmarkdown">
<p>However, Inter can do much more than simply convert between these forms. It
has a &quot;pipeline&quot; design, meaning that it can run memory inter through any
desired series of compilation stages, one at a time:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="element-syntax">T</span><span class="plain-syntax"> --------&gt; </span><span class="element-syntax">T</span><span class="plain-syntax"> --------&gt; </span><span class="element-syntax">T</span><span class="plain-syntax"> --------&gt; ... --------&gt; </span><span class="element-syntax">T</span>
<span class="plain-syntax">       </span><span class="element-syntax">step</span><span class="plain-syntax"> </span><span class="constant-syntax">1</span><span class="plain-syntax">      </span><span class="element-syntax">step</span><span class="plain-syntax"> </span><span class="constant-syntax">2</span><span class="plain-syntax">      </span><span class="element-syntax">step</span><span class="plain-syntax"> </span><span class="constant-syntax">3</span><span class="plain-syntax">   ...  </span><span class="element-syntax">step</span><span class="plain-syntax"> </span><span class="element-syntax">N</span>
</pre>
<div class="lsmarkdown">
<p>The Inter tree <code>T</code> starts out empty,<sup id="fnred:1"><a href="#fn:1" rel="footnote">1</a></sup> and at the end it is thrown away. So any
useful pipeline will begin by loading something in (usually as step 1), and
end by producing some useful output (usually in its last step or steps).</p>
<p>The advantage of this design is that it enables us to build what amount to
entirely different compilers, just by using different pipelines -- see
&quot;assimilation&quot; below for an example of a pipeline very different to the one
used in normal Inform 7 compilations. Pipelines also allow us to test existing
or proposed code-generation stages individually.</p>
<ul class="inwebfootnotetexts"><li class="footnote" id="fn:1"><p class="inwebfootnote"><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>
Programs in Inter format are called &quot;Inter trees&quot;.<a href="#fnref:1" title="return to text"> &#x21A9;</a></p>
</li></ul>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP3" class="paragraph-anchor"></a><b>&#167;3. Verify only.</b>  If you have compiled the standard distribution of the command-line tools
for Inform then the Inter executable will be at <code>inter/Tangled/inter</code>.</p>
<p>Inter has three basic modes. In the first, the command line specifies only
a single file:</p>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">inter/Tangled/inter</span><span class="ConsoleText-plain-syntax"> INTERFILE</span>
</pre>
<div class="lsmarkdown">
<p>Inter simply verifies this file for correctness: that is, to see if the inter
code supplied conforms to the inter specification. It returns the exit code 0
if all is well, and issues error messages and returns 1 if not.</p>
<p>Such files can be in either textual or binary form, and Inter automatically
detects which by looking at their contents. (Conventionally, such files
have the filename extension <code>.intert</code> or <code>.interb</code> respectively, but that's
not how Inter decides.)</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP4" class="paragraph-anchor"></a><b>&#167;4. Format conversion.</b>  In the second mode, Inter not only loads (and verifies) the named file, but
then converts it to a different format and writes that out. For example,</p>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">inter/Tangled/inter</span><span class="ConsoleText-plain-syntax"> my.intert</span><span class="ConsoleText-identifier-syntax"> -o</span><span class="ConsoleText-plain-syntax"> my.interb</span><span class="ConsoleText-identifier-syntax"> -format</span><span class="ConsoleText-plain-syntax">=binary</span>
</pre>
<div class="lsmarkdown">
<p>converts <code>my.intert</code> (a textual inter file) to its binary equivalent <code>my.interb</code>,
and conversely:</p>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">inter/Tangled/inter</span><span class="ConsoleText-plain-syntax"> my.interb</span><span class="ConsoleText-identifier-syntax"> -o</span><span class="ConsoleText-plain-syntax"> my.intert</span><span class="ConsoleText-identifier-syntax"> -format</span><span class="ConsoleText-plain-syntax">=text</span>
</pre>
<div class="lsmarkdown">
<p>Two parameters must be specified: <code>-o</code> giving the output file, and <code>-format=F</code>
to say what format <code>F</code> this should have. Formats are in the same notation as
those used by <a href="../inbuild/index.html" class="internal">inbuild</a>, which similarly supports <code>-o</code> and <code>-format</code>.
In fact, <code>-format=text</code> is the default.</p>
<p>To take an elaborate example,</p>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">inter/Tangled/inter</span><span class="ConsoleText-plain-syntax"> my.interb</span><span class="ConsoleText-identifier-syntax"> -o</span><span class="ConsoleText-plain-syntax"> my.intert</span><span class="ConsoleText-identifier-syntax"> -format</span><span class="ConsoleText-plain-syntax">=C/32d/nomain</span>
</pre>
<div class="lsmarkdown">
<p>generates a 32-bit-word, debugging-enabled ANSI C program from the Inter tree
in <code>my.interb</code>, with no <code>main</code> function included in it.</p>
<p>As a special case, if <code>-o</code> is given just as <code>-</code>, then the output is printed
to the console rather than to a file.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP5" class="paragraph-anchor"></a><b>&#167;5. Running a pipeline.</b>  If we specify <code>-trace</code> as a command-line switch, Inter prints out every step
of the pipeline(s) it is following. This reveals that even the simple commands
above are, in fact, running pipelines, albeit short ones:</p>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">inter/Tangled/inter</span><span class="ConsoleText-plain-syntax"> my.intert</span><span class="ConsoleText-identifier-syntax"> -trace</span>
<span class="ConsoleText-plain-syntax">    step 1/1: read &lt;- my.intert</span>
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">inter/Tangled/inter</span><span class="ConsoleText-plain-syntax"> my.intert</span><span class="ConsoleText-identifier-syntax"> -o</span><span class="ConsoleText-plain-syntax"> my.interb</span><span class="ConsoleText-identifier-syntax"> -format</span><span class="ConsoleText-plain-syntax">=binary</span><span class="ConsoleText-identifier-syntax"> -trace</span>
<span class="ConsoleText-plain-syntax">    step 1/2: read &lt;- my.intert</span>
<span class="ConsoleText-plain-syntax">    step 2/2: generate binary -&gt; my.interb</span>
</pre>
<div class="lsmarkdown">
<p>As this shows, a one or two-step pipeline was running:</p>
<ul>
<li>
<p>The first step used the <code>read</code> compilation stage, which reads some Inter
code into memory. Here, it comes from the file <code>my.intert</code>.</p>
</li>
<li>
<p>The second step used the <code>generate</code> stage, which writes out Inter code
in the format of one's choice -- here &quot;binary&quot;.</p>
</li>
</ul>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP6" class="paragraph-anchor"></a><b>&#167;6. </b>  However, we don't have to use this default pipeline. <code>-pipeline-text 'PIPELINE'</code>
reads in a textual description of the pipeline to follow, with the steps divided
by commas. The examples above used a pipeline which in this notation would
be written as:</p>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    -pipeline-text 'read &lt;- *in, generate -&gt; *out'</span>
</pre>
<div class="lsmarkdown">
<p><code>*in</code> and <code>*out</code> are examples of &quot;pipeline variables&quot;. <code>*in</code> is the filename
of whatever file is to be read in, and <code>*out</code> is whatever was specified by <code>-o</code>
at the command line, or in other words, the filename to write the output to.</p>
<p>This is not quite the smallest possible pipeline. Consider:</p>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">inter/Tangled/inter</span><span class="ConsoleText-identifier-syntax"> -o</span><span class="ConsoleText-plain-syntax"> my.intert</span><span class="ConsoleText-identifier-syntax"> -pipeline-text</span><span class="ConsoleText-plain-syntax"> 'new, generate -&gt; *out'</span><span class="ConsoleText-identifier-syntax"> -trace</span>
<span class="ConsoleText-plain-syntax">    step 1/2: new</span>
<span class="ConsoleText-plain-syntax">    step 2/2: generate text -&gt; my.intert</span>
</pre>
<div class="lsmarkdown">
<p>Here we didn't specify any Inter file to read in, so <code>*in</code> does not appear.
Instead wevbegan the pipeline with the <code>new</code> compilation stage, which creates
a minimal Inter program from nothing.</p>
<p>Even three-step pipelines can be very useful. For example:</p>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">inter/Tangled/inter</span><span class="ConsoleText-identifier-syntax"> -o</span><span class="ConsoleText-plain-syntax"> my.intert</span><span class="ConsoleText-identifier-syntax"> -pipeline-text</span><span class="ConsoleText-plain-syntax"> 'read &lt;- *in, eliminate-redundant-labels, generate -&gt; *out'</span><span class="ConsoleText-identifier-syntax"> -trace</span>
<span class="ConsoleText-plain-syntax">    step 1/3: read &lt;- my.intert</span>
<span class="ConsoleText-plain-syntax">    step 2/3: eliminate-redundant-labels</span>
<span class="ConsoleText-plain-syntax">    step 3/3: generate text -&gt; my.intert</span>
</pre>
<div class="lsmarkdown">
<p>This could be used to test that the <code>eliminate-redundant-labels</code> compilation
stage is working as it should. We can feed our choice of Inter code into it,
and examine its direct output, in isolation from the working of the rest of
the compiler (and, of course, more quickly).</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP7" class="paragraph-anchor"></a><b>&#167;7. </b>  In practice, it becomes cumbersome to spell the pipeline out longhand on
the command line, so we can also put it into a text file:</p>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">inter/Tangled/inter</span><span class="ConsoleText-identifier-syntax"> -pipeline-file</span><span class="ConsoleText-plain-syntax"> mypl.interpipeline</span>
</pre>
<div class="lsmarkdown">
<p>It's not allowed to specify both <code>-pipeline-file</code> and <code>-pipeline-text</code>.
The text file, however, specifies pipelines with one step on each line, not
using commas. So <code>-pipeline-text 'read &lt;- *in, eliminate-redundant-labels, generate -&gt; *out'</code>
is equivalent to <code>-pipeline-file</code> with the file:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">read</span><span class="plain-syntax"> &lt;- *</span><span class="identifier-syntax">in</span>
<span class="identifier-syntax">eliminate</span><span class="plain-syntax">-</span><span class="identifier-syntax">redundant</span><span class="plain-syntax">-</span><span class="identifier-syntax">labels</span>
<span class="identifier-syntax">generate</span><span class="plain-syntax"> </span><span class="constant-syntax">-</span><span class="plain-syntax">&gt; *</span><span class="identifier-syntax">out</span>
</pre>
<div class="lsmarkdown">
<p>For more on how to write and use pipeline files, see <a href="M-pas.html" class="internal">Pipelines and Stages</a>.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP8" class="paragraph-anchor"></a><b>&#167;8. </b>  In general, filenames follow the usual Unix conventions: they are taken as
relative to the current working directory, unless given as absolute filenames
beginning with <code>/</code>. But we can also set a &quot;default directory&quot; to take the
place of the CWD, using <code>-domain</code>:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="constant-syntax">-</span><span class="identifier-syntax">domain</span><span class="plain-syntax"> </span><span class="identifier-syntax">D</span>
</pre>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP9" class="paragraph-anchor"></a><b>&#167;9. Assimilation.</b>  Inform makes use of what are called &quot;kits&quot; of pre-compiled Inter code:
for example, <code>CommandParserKit</code> contains code for the traditional interactive
fiction command parser. That pre-compilation is called &quot;assimilation&quot;, and
is performed by the <a href="index.html" class="internal">inter</a> tool alone: it does not require, or use, the
bulk of the <a href="../inform7/index.html" class="internal">inform7</a> compiler.</p>
<p>The source code for a kit could in principle be textual Inter, but that's too
verbose to write comfortably. In practice we use Inform 6 code as a notation,
and therefore assimilation is really compilation from I6 to Inter.</p>
<p>Kits are like so-called &quot;fat binaries&quot;, in that they contain binary Inter
for each different architecture with which they are compatible. Inter can
build kits for only one architecture at a time, so a command must specify
which is wanted. For example:</p>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">inter/Tangled/inter</span><span class="ConsoleText-identifier-syntax"> -architecture</span><span class="ConsoleText-plain-syntax"> 16</span><span class="ConsoleText-identifier-syntax"> -build-kit</span><span class="ConsoleText-plain-syntax"> inform7/Internal/Inter/BasicInformKit</span>
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">inter/Tangled/inter</span><span class="ConsoleText-identifier-syntax"> -architecture</span><span class="ConsoleText-plain-syntax"> 32d</span><span class="ConsoleText-identifier-syntax"> -build-kit</span><span class="ConsoleText-plain-syntax"> inform7/Internal/Inter/BasicInformKit</span>
</pre>
<div class="lsmarkdown">
<p>At present there are four architectures: <code>16</code>, <code>16d</code>, <code>32</code> and <code>32d</code>.
Note that an architecture is not the same thing as a format: it specifies
only the word size (16 or 32 bit) and the presence, or not, of debugging data.</p>
<p>Incrementally building kits as needed could be done with something like
the Unix tool <code>make</code>, but in fact Inbuild has this ability: the command</p>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">inbuild/Tangled/inbuild</span><span class="ConsoleText-identifier-syntax"> -build</span><span class="ConsoleText-plain-syntax"> K</span>
</pre>
<div class="lsmarkdown">
<p>looks at the kit <code>K</code>, works out which architectures need rebuilding, and
then issues commands like the above to instruct <code>inter</code> to do so. Indeed,
multiple kits can be managed with a single command:</p>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">inbuild/Tangled/inbuild</span><span class="ConsoleText-identifier-syntax"> -build -contents-of</span><span class="ConsoleText-plain-syntax"> inform7/Internal/Inter</span>
</pre>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP10" class="paragraph-anchor"></a><b>&#167;10. </b>  Under the hood, assimilation is just another use of pipeline processing. If we
run one of these <code>-build-kit</code> commands with <code>-trace</code> switched on, we see
something like this:</p>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">step 1/6: new</span>
<span class="ConsoleText-plain-syntax">step 2/6: load-kit-source &lt;- BasicInformKit</span>
<span class="ConsoleText-plain-syntax">step 3/6: parse-insertions</span>
<span class="ConsoleText-plain-syntax">step 4/6: resolve-conditional-compilation</span>
<span class="ConsoleText-plain-syntax">step 5/6: compile-splats</span>
<span class="ConsoleText-plain-syntax">step 6/6: generate binary -&gt; inform7/Internal/Inter/BasicInformKit/arch-32.interb</span>
</pre>
<div class="lsmarkdown">
<p>This is in fact the result of running a pipeline file called <code>build-kit.interpipeline</code>
which is included in the standard Inter distribution.</p>
</div>
<nav role="progress"><div class="progresscontainer">
    <ul class="progressbar"><li class="progressprevoff">&#10094;</li><li class="progresscurrentchapter">M</li><li class="progresscurrent">ui</li><li class="progresssection"><a href="M-ti.html">ti</a></li><li class="progresssection"><a href="M-dpiti.html">dpiti</a></li><li class="progresssection"><a href="M-cpiti.html">cpiti</a></li><li class="progresssection"><a href="M-ip.html">ip</a></li><li class="progresssection"><a href="M-ia.html">ia</a></li><li class="progresssection"><a href="M-io.html">io</a></li><li class="progresssection"><a href="M-pas.html">pas</a></li><li class="progresssection"><a href="M-rc.html">rc</a></li><li class="progresschapter"><a href="1-mn.html">1</a></li><li class="progressnext"><a href="M-ti.html">&#10095;</a></li></ul></div>
</nav><!-- End of weave -->

		</main>
	</body>
</html>

