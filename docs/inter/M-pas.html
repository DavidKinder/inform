<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>Pipelines and Stages</title>
<link href="../docs-assets/Breadcrumbs.css" rel="stylesheet" rev="stylesheet" type="text/css">
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">

<link href="../docs-assets/Contents.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Progress.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Navigation.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Fonts.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Base.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script src="http://code.jquery.com/jquery-1.12.4.min.js"
	integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>

<script src="../docs-assets/Bigfoot.js"></script>
<link href="../docs-assets/Bigfoot.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/ConsoleText-Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
		
	</head>
	<body class="commentary-font">
		<nav role="navigation">
		<h1><a href="../index.html"><img src="../docs-assets/Inform.png" height=72> </a></h1>
<ul><li><a href="../index.html">home</a></li>
</ul><h2>Compiler</h2><ul>
<li><a href="../structure.html">structure</a></li>
<li><a href="../inbuildn.html">inbuild</a></li>
<li><a href="../inform7n.html">inform7</a></li>
<li><a href="../intern.html">inter</a></li>
<li><a href="../services.html">services</a></li>
<li><a href="../secrets.html">secrets</a></li>
</ul><h2>Other Tools</h2><ul>
<li><a href="../inblorbn.html">inblorb</a></li>
<li><a href="../inform6.html">inform6</a></li>
<li><a href="../inpolicyn.html">inpolicy</a></li>
</ul><h2>Resources</h2><ul>
<li><a href="../extensions.html">extensions</a></li>
<li><a href="../kits.html">kits</a></li>
</ul><h2>Repository</h2><ul>
<li><a href="https://github.com/ganelson/inform"><img src="../docs-assets/github.png" height=0> github</a></li>
</ul><h2>Related Projects</h2><ul>
<li><a href="https://github.com/ganelson/inweb"><img src="../docs-assets/github.png" height=0> inweb</a></li>
<li><a href="https://github.com/ganelson/intest"><img src="../docs-assets/github.png" height=0> intest</a></li>
</ul>
		</nav>
		<main role="main">
		<!-- Weave of 'Pipelines and Stages' generated by inweb -->
<div class="breadcrumbs">
    <ul class="crumbs"><li><a href="../index.html">Home</a></li><li><a href="index.html">inter</a></li><li><a href="index.html#M">Manual</a></li><li><b>Pipelines and Stages</b></li></ul></div>
<p class="purpose">Sequences of named code-generation stages are called pipelines.</p>

<ul class="toc"><li><a href="M-pas.html#SP1">&#167;1. Variables and filenames</a></li><li><a href="M-pas.html#SP4">&#167;4. Pipelines run by Inform</a></li><li><a href="M-pas.html#SP5">&#167;5. Syntax of pipeline descriptions</a></li><li><a href="M-pas.html#SP7">&#167;7. Dictionary of stages</a></li></ul><hr class="tocbar">

<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP1" class="paragraph-anchor"></a><b>&#167;1. Variables and filenames.</b>  For an introduction to pipelines, first read the section <a href="M-ui.html" class="internal">Using Inter</a>.</p>
<p>In that section, two variables <code>*in</code> and <code>*out</code> appeared, but no others.
Those were automatically set as needed: <code>*in</code> was the file specified first
in the command, while <code>*out</code> was the value of the <code>-o</code> output file switch.</p>
<p>In fact, though, any number of variables can be set at the command line.
<code>-variable '*magicword=zooge'</code>, for example, creates the variable <code>*magicword</code>
and sets its initial value to &quot;zooge&quot;.</p>
<p>Of course, this has no practical effect unless the pipeline we are running
makes use of such a variable. But we might imagine running:</p>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">inter/Tangled/inter</span><span class="ConsoleText-plain-syntax"> my.intert</span><span class="ConsoleText-identifier-syntax"> -pipeline-file</span><span class="ConsoleText-plain-syntax"> mypl.interpipeline</span><span class="ConsoleText-identifier-syntax"> -variable</span><span class="ConsoleText-plain-syntax"> '*textual=v1.intert'</span><span class="ConsoleText-identifier-syntax"> -variable</span><span class="ConsoleText-plain-syntax"> '*binary=v2.interb'</span>
</pre>
<div class="lsmarkdown">
<p>where <code>mypl.interpipeline</code> reads:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">read</span><span class="plain-syntax"> &lt;- *</span><span class="identifier-syntax">in</span>
<span class="identifier-syntax">generate</span><span class="plain-syntax"> </span><span class="identifier-syntax">text</span><span class="plain-syntax"> </span><span class="constant-syntax">-</span><span class="plain-syntax">&gt; *</span><span class="identifier-syntax">textual</span>
<span class="identifier-syntax">generate</span><span class="plain-syntax"> </span><span class="identifier-syntax">binary</span><span class="plain-syntax"> </span><span class="constant-syntax">-</span><span class="plain-syntax">&gt; *</span><span class="identifier-syntax">binary</span>
</pre>
<div class="lsmarkdown">
<p>This will then write out the same Inter program in two different formats, to
two different files.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP2" class="paragraph-anchor"></a><b>&#167;2. </b>  Variables hold only text, and generally represent filenames. Variable names
begin with a star <code>*</code>. When a pipeline runs, the value of a variable is
substituted for its name. For example,</p>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">inter/Tangled/inter</span><span class="ConsoleText-identifier-syntax"> -variable</span><span class="ConsoleText-plain-syntax"> '*X=ex/why'</span><span class="ConsoleText-identifier-syntax"> -pipeline-file</span><span class="ConsoleText-plain-syntax"> mypl.interpipeline</span>
</pre>
<div class="lsmarkdown">
<p>creates the variable <code>*X</code> with the textual contents <code>ex/why</code> before running
the given pipeline. Inside the pipeline, a line such as:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    generate inform6 </span><span class="type-syntax">-&gt;</span><span class="plain-syntax"> </span><span class="identifier-syntax">*X</span>
</pre>
<div class="lsmarkdown">
<p>would then be read as:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    generate inform6 </span><span class="type-syntax">-&gt;</span><span class="plain-syntax"> ex/why</span>
</pre>
<div class="lsmarkdown">
<p>After variable substitution like this, filenames inside the pipeline
description are interpreted as follows:</p>
<ul>
<li>If a filename contains a slash character, it is considered a literal
filename.</li>
<li>If the filename is just <code>-</code>, it is considered to mean the console, that
is, what in Unix is usually called <code>stdout</code>. In other words, output is printed
rather than saved.</li>
<li>If not, it is considered to be a leafname inside the &quot;domain&quot; directory.
By default this is the current working directory, but using <code>-domain</code> at
the Inter command line changes that.</li>
</ul>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP3" class="paragraph-anchor"></a><b>&#167;3. </b>  The special variable <code>*log</code>, which always exists, means the debugging log.
A command to write a text file to <code>*log</code> is interpreted instead to mean
&quot;spool the output you would otherwise write to the debugging log instead&quot;.
For example,</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    generate inventory </span><span class="type-syntax">-&gt;</span><span class="plain-syntax"> </span><span class="identifier-syntax">*log</span>
</pre>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP4" class="paragraph-anchor"></a><b>&#167;4. Pipelines run by Inform.</b>  To Inbuild and Inform, pipelines are resources in their own right, rather
like extensions or kits. So, for example, the standard distribution includes</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">inform7</span><span class="plain-syntax">/</span><span class="identifier-syntax">Internal</span><span class="plain-syntax">/</span><span class="identifier-syntax">Pipelines</span><span class="plain-syntax">/</span><span class="identifier-syntax">compile</span><span class="plain-syntax">.</span><span class="identifier-syntax">interpipeline</span>
</pre>
<div class="lsmarkdown">
<p>which is the one used for standard compilation runs. A project's Materials
folder is free to provide a replacement:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">Strange</span><span class="plain-syntax">.</span><span class="identifier-syntax">materials</span><span class="plain-syntax">/</span><span class="identifier-syntax">Pipelines</span><span class="plain-syntax">/</span><span class="identifier-syntax">compile</span><span class="plain-syntax">.</span><span class="identifier-syntax">interpipeline</span>
</pre>
<blockquote>
    <p>Use inter pipeline "NAME".</p>
</blockquote>

<blockquote>
    <p>Use inter pipeline "mypipeline".</p>
</blockquote>

<div class="lsmarkdown">
<p>...and then this will be used instead when compiling <code>Strange.inform</code>.</p>
<ol>
<li>This sentence in Inform source text:</li>
</ol>
</div>
<div class="lsmarkdown">
<p>replaces the pipeline normally used for code generation with the one supplied.
(That may very well cause the compiler not to produce viable code, of course.)
The default Inter pipeline is called <code>compile</code>, and comes built-in. Named
pipelines are stored alongside named extensions and other resources used by
Inform; so for example you could write:</p>
</div>
<div class="lsmarkdown">
<p>And then store the actual pipeline file as:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">Example</span><span class="plain-syntax"> </span><span class="identifier-syntax">Work</span><span class="plain-syntax">.</span><span class="identifier-syntax">materials</span><span class="plain-syntax">/</span><span class="identifier-syntax">Pipelines</span><span class="plain-syntax">/</span><span class="identifier-syntax">mypipeline</span><span class="plain-syntax">.</span><span class="identifier-syntax">interpipeline</span>
</pre>
<div class="lsmarkdown">
<ol start="2">
<li>You don't need the Use... sentence, though, if you're willing to choose
on the command line instead:</li>
</ol>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">inform7/Tangled/inform7</span><span class="ConsoleText-plain-syntax"> ...</span><span class="ConsoleText-identifier-syntax"> -pipeline</span><span class="ConsoleText-plain-syntax"> NAME</span>
</pre>
<div class="lsmarkdown">
<p>Or, if you want to name a file explicitly, not have it looked for by name:</p>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">inform7/Tangled/inform7</span><span class="ConsoleText-plain-syntax"> ...</span><span class="ConsoleText-identifier-syntax"> -pipeline-file</span><span class="ConsoleText-plain-syntax"> FILE</span>
</pre>
<div class="lsmarkdown">
<ol start="3">
<li>Finally, you can also give Inform 7 an explicit pipeline in textual form:</li>
</ol>
</div>
<pre class="ConsoleText-displayed-code all-displayed-code code-font">
<span class="ConsoleText-plain-syntax">    </span><span class="ConsoleText-element-syntax">$</span><span class="ConsoleText-plain-syntax"> </span><span class="ConsoleText-function-syntax">inform7/Tangled/inform7</span><span class="ConsoleText-plain-syntax"> ...</span><span class="ConsoleText-identifier-syntax"> -pipeline-text</span><span class="ConsoleText-plain-syntax"> 'PIPELINE'</span>
</pre>
<div class="lsmarkdown">
<p>Note that Inbuild and Inform 7 respond to all three of <code>-pipeline</code>,
<code>-pipeline-file</code> and <code>-pipeline-text</code>, whereas Inter responds only to the
last two. (It can't find pipelines by name because it doesn't contain the
supervisor module for sorting out resources.)</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP5" class="paragraph-anchor"></a><b>&#167;5. Syntax of pipeline descriptions.</b>  Pipelines are, roughly speaking, just lists of steps. Each step occupies a single
line: blank lines are ignored, and so are lines whose first non-white-space
character is a <code>!</code>, which are considered comments.</p>
<p>A step description is often as simple as being the name of a stage, but
sometimes that name is accompanied by parameters.</p>
<p>The difference between a step and a stage is illustrated by this example:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="comment-syntax">! This is a comment</span>

<span class="plain-syntax">    read </span><span class="type-syntax">&lt;-</span><span class="plain-syntax"> </span><span class="identifier-syntax">*in</span>

<span class="plain-syntax">    generate text </span><span class="type-syntax">-&gt;</span><span class="plain-syntax"> </span><span class="identifier-syntax">*tout</span>
<span class="plain-syntax">    generate binary </span><span class="type-syntax">-&gt;</span><span class="plain-syntax"> </span><span class="identifier-syntax">*bout</span>
</pre>
<div class="lsmarkdown">
<p>Here there are three steps. The first uses the <code>read</code> stage; the second and
third use the <code>generate</code> stage, but with different parameters.</p>
<p>There are three sorts of stage description: those involving material coming
in, denoted by a left arrow, those involving some external file being written
out, denoted by a right arrow, and those which just process what we have.
These take the following forms:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    STAGENAME [TREE] </span><span class="type-syntax">&lt;-</span><span class="plain-syntax"> SOURCE</span>
<span class="plain-syntax">    STAGENAME [TREE] [FORMAT] </span><span class="type-syntax">-&gt;</span><span class="plain-syntax"> DESTINATION</span>
<span class="plain-syntax">    STAGENAME [TREE]</span>
</pre>
<div class="lsmarkdown">
<p>The <code>STAGENAME</code> never contains white space; hyphens are used instead. So, for
example, <code>eliminate-redundant-labels</code> is a valid <code>STAGENAME</code>.</p>
<p>The <code>[TREE]</code> is optional. For example:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    read </span><span class="constant-syntax">2</span><span class="plain-syntax"> </span><span class="type-syntax">&lt;-</span><span class="plain-syntax"> </span><span class="identifier-syntax">*in</span>
<span class="plain-syntax">    generate </span><span class="constant-syntax">3</span><span class="plain-syntax"> </span><span class="type-syntax">-&gt;</span><span class="plain-syntax"> </span><span class="identifier-syntax">*out</span>
</pre>
<div class="lsmarkdown">
<p>Pipeline descriptions allow us to manage up to 10 different Inter trees, and
these are called <code>0</code> to <code>9</code>. These are all initially empty. Any stage which
doesn't specify a tree is considered to apply to <code>0</code>; so pipelines often never
mention the digits <code>0</code> to <code>9</code> at all because they always work inside <code>0</code>.</p>
<p>Another optional feature, not currently made use of by any stages, is that
the description can specify an exact package in a tree, giving its name in URL
form. Thus:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    hypothetical-stage /main/whatever</span>
<span class="plain-syntax">    hypothetical-stage </span><span class="constant-syntax">6</span><span class="plain-syntax">:/main/whatever</span>
</pre>
<div class="lsmarkdown">
<p>The stages currently built in to <a href="index.html" class="internal">inter</a> do not work on individual packages,
but they did at one time in the past, and the infrastructure for it remains
in case useful in future.</p>
<p>SOURCE and DESTINATION specify, usually, files to read or write, but they are
often in fact given as variables, whose names start with an asterisk <code>*</code>.
Variables have to be set in advance, either at the command line (see above)
or by the tool calling for the pipeline to be run, e.g., the <a href="../supervisor-module/index.html" class="internal">supervisor</a>
module inside Inform 7.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP6" class="paragraph-anchor"></a><b>&#167;6. </b>  Pipelines can also include each other. For example, the step:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    run pipeline assimilate</span>
</pre>
<div class="lsmarkdown">
<p>causes the whole <code>assimilate</code> pipeline to be run at that point. Indeed, Inform 7's
main pipeline <code>compile</code> uses this to break its task into subtasks:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">read </span><span class="type-syntax">&lt;-</span><span class="plain-syntax"> </span><span class="identifier-syntax">*in</span>

<span class="plain-syntax">run pipeline assimilate</span>
<span class="plain-syntax">run pipeline link</span>
<span class="plain-syntax">run pipeline optimise</span>

<span class="comment-syntax">! The following does nothing if the variable *tout does not exist and it</span>
<span class="comment-syntax">! will exist only when debugging:</span>
<span class="plain-syntax">optionally-generate text </span><span class="type-syntax">-&gt;</span><span class="plain-syntax"> </span><span class="identifier-syntax">*tout</span>

<span class="plain-syntax">generate </span><span class="type-syntax">-&gt;</span><span class="plain-syntax"> </span><span class="identifier-syntax">*out</span>
<span class="plain-syntax">index</span>
</pre>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP7" class="paragraph-anchor"></a><b>&#167;7. Dictionary of stages.</b>  The following gives a brief guide to the available stages, in alphabetical
order. See also <a href="../pipeline-module/P-wtmd.html" class="internal">What This Module Does (in pipeline)</a> for how (some of) these
stages are used when building kits or projects.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP8" class="paragraph-anchor"></a><b>&#167;8. </b>  <code>compile-splats</code>.
A &quot;splat&quot; node holds a single Inform 6-written statement or directive, and
thus represents not-yet-compiled material. This stage converts all remaining
splat nodes to Inter code. Note that <code>resolve-conditional-compilation</code> must
already have run for this to handle <code>#ifdef</code> and the like properly.</p>
<p>For the implementation, see <a href="../pipeline-module/3-css.html" class="internal">Compile Splats Stage (in pipeline)</a>.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP9" class="paragraph-anchor"></a><b>&#167;9. </b>  <code>detect-indirect-calls</code>.
Handles an edge case in linking where a function call in one compilation unit,
e.g., <code>X(1)</code>, turned out more complicated because <code>X</code>, defined in another
compilation unit, was a variable holding the address of a function, and not
as expected the name of a specific function.</p>
<p>For the implementation, see <a href="../pipeline-module/4-dics.html" class="internal">Detect Indirect Calls Stage (in pipeline)</a>.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP10" class="paragraph-anchor"></a><b>&#167;10. </b>  <code>eliminate-redundant-labels</code>.
Performs peephole optimisation on functions to remove all labels which are
declared but can never be jumped to. At the end of this stage, all labels
inside functions are targets of some branch, either by <code>inv !jump</code> or in
assembly language.</p>
<p>For the implementation, see <a href="../pipeline-module/6-erls.html" class="internal">Eliminate Redundant Labels Stage (in pipeline)</a>.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP11" class="paragraph-anchor"></a><b>&#167;11. </b>  <code>eliminate-redundant-matter</code>.
Works through the dependency graph of the Inter tree to find packages which
are never needed (such as functions never called), and remove them, thus
making the final executable smaller.</p>
<p>Note that this is experimental, does not yet properly work, and is not used
in the built-in <code>compile</code> pipeline.</p>
<p>For the implementation, see <a href="../pipeline-module/6-erms.html" class="internal">Eliminate Redundant Matter Stage (in pipeline)</a>.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP12" class="paragraph-anchor"></a><b>&#167;12. </b>  <code>eliminate-redundant-operations</code>.
Performs peephole optimisation on functions to remove arithmetic or logical
operations which can be proved to have neither a direct effect nor any
side-effect: for example, performing <code>x + 0</code> rather than just evaluating <code>x</code>.</p>
<p>For the implementation, see <a href="../pipeline-module/6-eros.html" class="internal">Eliminate Redundant Operations Stage (in pipeline)</a>.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP13" class="paragraph-anchor"></a><b>&#167;13. </b>  <code>generate [FORMAT] -&gt; [DESTINATION]</code>.
Produces &quot;final code&quot; in some format, writing it to an external file specified
as the destination. If not given, the format will be the one chosen by the
<a href="../supervisor-module/index.html" class="internal">supervisor</a> module.</p>
<p>Note that the special destination <code>*log</code> writes to the debugging log rather
than to some other external file.</p>
<p>The current list of valid formats is: <code>inform6</code>, <code>c</code>, <code>binary</code>, <code>text</code>, <code>inventory</code>.
Of these <code>binary</code> and <code>text</code> are faithful, direct representations of Inter trees;
<code>inventory</code> is a human-readable summary of the contents; but the others are
genuine conversions to code which can be run through other compilers to
make executable programs.</p>
<p>For the implementation, see <a href="../final-module/2-cg.html" class="internal">Code Generation (in final)</a>.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP14" class="paragraph-anchor"></a><b>&#167;14. </b>  <code>index</code>.
This is functional only when run as part of the compilation pipeline used on
code generated by Inform 7; it will (silently) do nothing if used in any other
pipeline. Depending on command-line settings, it also updates extension documentation
and generates an EPS form of the map of an IF project.</p>
<p>For the implementation, see <a href="../index-module/1-is.html" class="internal">Index Stage (in index)</a>.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP15" class="paragraph-anchor"></a><b>&#167;15. </b>  <code>load-binary-kits</code>.
Kits are libraries of Inter code which support the operation of Inform programs
at runtime. When &quot;built&quot; (using <a href="index.html" class="internal">inter</a> with the <code>build-kit</code> pipeline), a
kit provides a binary Inter file of code for each possible architecture. This
stage gathers up all needed kits, and loads them into the current tree, thus
considerably expanding it.</p>
<p>Note that the list of &quot;needed&quot; kits has to be specified in advance of the pipeline
being run. For Inform compilations, this is handled automatically by the
<a href="../supervisor-module/index.html" class="internal">supervisor</a> module, but it can also be done via the command line.</p>
<p>For the implementation, see <a href="../pipeline-module/4-lbks.html" class="internal">Load Binary Kits Stage (in pipeline)</a>.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP16" class="paragraph-anchor"></a><b>&#167;16. </b>  <code>load-kit-source &lt;- [SOURCE]</code>.
Reads a file of Inform 6-syntax source code and adds the resulting material to
the Inter tree in the form of a series of &quot;splat&quot; nodes, one for each statement
or directive. Those won't be much use as they stand, but see <code>compile-splats</code>.</p>
<p>For the implementation, see <a href="../pipeline-module/3-ps.html" class="internal">Parsing Stages (in pipeline)</a>.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP17" class="paragraph-anchor"></a><b>&#167;17. </b>  <code>make-identifiers-unique</code>.
Ensures that symbols marked as needing to be unique will be translated, during
any use of <code>generate</code>, to identifiers which are all different from each other
across the entire tree. (In effect, this stage is needed because Inter has
private namespaces within packages, whereas the languages we are transpiling to --
to some extent C, but certainly Inform 6 -- have a single global namespace,
where collisions of identifiers would be very unfortunate.)</p>
<p>At the end of this stage, no symbol still has the <code>MAKE_NAME_UNIQUE_ISYMF</code> flag.</p>
<p>For the implementation, see <a href="../pipeline-module/4-mius.html" class="internal">Make Identifiers Unique Stage (in pipeline)</a>.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP18" class="paragraph-anchor"></a><b>&#167;18. </b>  <code>make-synoptic-module</code>.
The synoptic module is a top-level section of material in the Inter tree which
contains functions and arrays which index or otherwise gather up material
ranging across all other modules. For example, each module originally presents
itself with its own pieces of literal text, but the synoptic module then
collates all of those together, sorted and de-duplicated.</p>
<p>For the implementation, see <a href="../pipeline-module/5-msms.html" class="internal">Make Synoptic Module Stage (in pipeline)</a>.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP19" class="paragraph-anchor"></a><b>&#167;19. </b>  <code>move &lt;- LOCATION</code>.
This moves a branch of one Inter tree to a position in another one, reconciling
the necessary symbol dependencies. For example, <code>move 1 &lt;- 3:/main/my_fn</code>
moves the package <code>/main/my_fn</code> in tree 3 to the same position in tree 1.
Note that this is a move, not a copy, and is as fast an operation as we can
make it.</p>
<p>This stage is not used in the regular Inform pipelines, but exists to assist
testing of the so-called &quot;transmigration&quot; process, which powers <code>load-binary-kits</code>
(see above).</p>
<p>For the implementation, see <a href="../pipeline-module/2-rmss.html" class="internal">Read, Move, Stop Stages (in pipeline)</a>.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP20" class="paragraph-anchor"></a><b>&#167;20. </b>  <code>new</code>.
A completely empty Inter tree is not very useful. <code>new</code> adds the very basic
definitions needed, and gives it a <code>/main</code> package.</p>
<p>For the implementation, see <a href="../pipeline-module/2-ns.html" class="internal">New Stage (in pipeline)</a>.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP21" class="paragraph-anchor"></a><b>&#167;21. </b>  <code>optionally-generate [FORMAT] -&gt; DESTINATION</code>.
This is identical to <code>generate</code> except that if the DESTINATION is given as
a variable which does not exist then no error is produced, and nothing is done.</p>
<p>For the implementation, see <a href="../final-module/2-cg.html" class="internal">Code Generation (in final)</a>.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP22" class="paragraph-anchor"></a><b>&#167;22. </b>  <code>parse-insertions</code>.
This looks for <code>INSERT_IST</code> nodes in the tree, a small number of which may have
been created by the <a href="../inform7/index.html" class="internal">inform7</a> compiler in response to uses of <code>Include (- ... -)</code>.
These can hold arbitrarily long runs of Inform 6-syntax source code, and what
<code>parse-insertions</code> does is to break then up into splats, one for each statement
or directive. Those won't be much use as they stand, but see <code>compile-splats</code>.</p>
<p>When this completes, no <code>INSERT_IST</code> nodes remain in the tree.</p>
<p>For the implementation, see <a href="../pipeline-module/3-ps.html" class="internal">Parsing Stages (in pipeline)</a>.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP23" class="paragraph-anchor"></a><b>&#167;23. </b>  <code>read &lt;- SOURCE</code>.
Copies the contents of the SOURCE file to be the new contents of the tree.
The file must be an Inter file, but can be in either binary or textual format.</p>
<p>The special source <code>*memory</code> can be used if we already have a tree set up in
slot 0; this is a device used by the <a href="../supervisor-module/index.html" class="internal">supervisor</a> when managing an Inform
compilation, because <a href="../inform7/index.html" class="internal">inform7</a> will already have made an Inter tree in
memory, and it would be inefficient to save this out to the file system and
then read it in again.</p>
<p>For the implementation, see <a href="../pipeline-module/2-rmss.html" class="internal">Read, Move, Stop Stages (in pipeline)</a>.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP24" class="paragraph-anchor"></a><b>&#167;24. </b>  <code>reconcile-verbs</code>.
Looks for clashes between any verbs (i.e., command parser imperatives like
PURLOIN or LOOK) which are created in different compilation units. For example,
if the main source text creates a verb called ABSTRACT, which clashes with the
completely different command ABSTRACT defined in <code>CommandParserKit</code> for debugging
purposes, then how is the player to differentiate these? The <code>reconcile-verbs</code>
stage inserts <code>!</code> characters in the kit definitions where such clashes occur;
thus ABSTRACT would be the source-text-defined command, and !ABSTRACT the
kit-defined one.</p>
<p>At the end of this stage, all command parser verbs have distinct textual forms.</p>
<p>For the implementation, see <a href="../pipeline-module/4-rvs.html" class="internal">Reconcile Verbs Stage (in pipeline)</a>.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP25" class="paragraph-anchor"></a><b>&#167;25. </b>  <code>resolve-conditional-compilation</code>.
Looks for splats arising from Inform 6-syntax conditional compilation directives
such as <code>#ifdef</code>, <code>#ifndef</code>, <code>#endif</code>; it then detects whether the relevant
symbols are defined, or looks at their values, and deletes sections of code not
to be compiled. At the end of this stage, there are no conditional compilation
splats left in the tree. For example:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="type-syntax">constant</span><span class="plain-syntax"> (</span><span class="type-syntax">int32</span><span class="plain-syntax">) MAGIC = </span><span class="constant-syntax">12345</span>
<span class="plain-syntax">    </span><span class="type-syntax">splat</span><span class="plain-syntax"> IFTRUE &amp;</span><span class="string-syntax">"#iftrue MAGIC == 12345;\n"</span>
<span class="plain-syntax">    </span><span class="type-syntax">constant</span><span class="plain-syntax"> (</span><span class="type-syntax">int32</span><span class="plain-syntax">) WIZARD = </span><span class="constant-syntax">5</span>
<span class="plain-syntax">    </span><span class="type-syntax">splat</span><span class="plain-syntax"> IFNOT &amp;</span><span class="string-syntax">"#ifnot;\n"</span>
<span class="plain-syntax">    </span><span class="type-syntax">constant</span><span class="plain-syntax"> (</span><span class="type-syntax">int32</span><span class="plain-syntax">) MUGGLE = </span><span class="constant-syntax">0</span>
<span class="plain-syntax">    </span><span class="type-syntax">splat</span><span class="plain-syntax"> ENDIF &amp;</span><span class="string-syntax">"#endif;\n"</span>
</pre>
<div class="lsmarkdown">
<p>is resolved to:</p>
</div>
<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="type-syntax">constant</span><span class="plain-syntax"> (</span><span class="type-syntax">int32</span><span class="plain-syntax">) MAGIC = </span><span class="constant-syntax">12345</span>
<span class="plain-syntax">    </span><span class="type-syntax">constant</span><span class="plain-syntax"> (</span><span class="type-syntax">int32</span><span class="plain-syntax">) WIZARD = </span><span class="constant-syntax">5</span>
</pre>
<div class="lsmarkdown">
<p>For the implementation, see <a href="../pipeline-module/3-rccs.html" class="internal">Resolve Conditional Compilation Stage (in pipeline)</a>.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP26" class="paragraph-anchor"></a><b>&#167;26. </b>  <code>shorten-wiring</code>.
Wiring is the process by which symbols in one package can refer to definitions
in another one; we say S is wired to T if S in one package refers to the meaning
defined by T is another one. The linking process can result in extended chains
of wiring, with A wired to B which is wired to C which... and so on; the
<code>shorten-wiring</code> stage cuts out those intermediate links so that if a symbol
S is wired to T then T is not wired to anything else.</p>
<p>For the implementation, see <a href="../pipeline-module/4-sws.html" class="internal">Shorten Wiring Stage (in pipeline)</a>.</p>
</div>
<div class="lsmarkdown">
<p class="commentary firstcommentary"><a id="SP27" class="paragraph-anchor"></a><b>&#167;27. </b>  <code>stop</code>.
The special stage <code>stop</code> halts processing of the pipeline midway. At present
this is only useful for making experimental edits to pipeline descriptions
to see what just the first half does, without deleting the second half of
the description.</p>
<p>For the implementation, see <a href="../pipeline-module/2-rmss.html" class="internal">Read, Move, Stop Stages (in pipeline)</a>.</p>
</div>
<nav role="progress"><div class="progresscontainer">
    <ul class="progressbar"><li class="progressprev"><a href="M-io.html">&#10094;</a></li><li class="progresscurrentchapter">M</li><li class="progresssection"><a href="M-ui.html">ui</a></li><li class="progresssection"><a href="M-ti.html">ti</a></li><li class="progresssection"><a href="M-dpiti.html">dpiti</a></li><li class="progresssection"><a href="M-cpiti.html">cpiti</a></li><li class="progresssection"><a href="M-ip.html">ip</a></li><li class="progresssection"><a href="M-ia.html">ia</a></li><li class="progresssection"><a href="M-io.html">io</a></li><li class="progresscurrent">pas</li><li class="progresssection"><a href="M-rc.html">rc</a></li><li class="progresschapter"><a href="1-mn.html">1</a></li><li class="progressnext"><a href="M-rc.html">&#10095;</a></li></ul></div>
</nav><!-- End of weave -->

		</main>
	</body>
</html>

