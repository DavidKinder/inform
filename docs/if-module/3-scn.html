<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>Scenes</title>
<link href="../docs-assets/Breadcrumbs.css" rel="stylesheet" rev="stylesheet" type="text/css">
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">

<link href="../docs-assets/Contents.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Progress.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Navigation.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Fonts.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Base.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script>
function togglePopup(material_id) {
  var popup = document.getElementById(material_id);
  popup.classList.toggle("show");
}
</script>

<link href="../docs-assets/Popups.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Preform-Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
		
	</head>
	<body class="commentary-font">
		<nav role="navigation">
		<h1><a href="../index.html">
<img src="../docs-assets/Inform.png" height=72">
</a></h1>
<ul><li><a href="../index.html">home</a></li>
</ul><h2>Compiler</h2><ul>
<li><a href="../structure.html">structure</a></li>
<li><a href="../inbuildn.html">inbuild</a></li>
<li><a href="../inform7n.html">inform7</a></li>
<li><a href="../intern.html">inter</a></li>
<li><a href="../services.html">services</a></li>
<li><a href="../secrets.html">secrets</a></li>
</ul><h2>Other Tools</h2><ul>
<li><a href="../inblorbn.html">inblorb</a></li>
<li><a href="../indocn.html">indoc</a></li>
<li><a href="../inform6.html">inform6</a></li>
<li><a href="../inpolicyn.html">inpolicy</a></li>
<li><a href="../inrtpsn.html">inrtps</a></li>
</ul><h2>Resources</h2><ul>
<li><a href="../extensions.html">extensions</a></li>
<li><a href="../kits.html">kits</a></li>
</ul><h2>Repository</h2><ul>
<li><a href="https://github.com/ganelson/inform"><img src="../docs-assets/github.png" height=18> github</a></li>
</ul><h2>Related Projects</h2><ul>
<li><a href="../../../inweb/index.html">inweb</a></li>
<li><a href="../../../intest/index.html">intest</a></li>

</ul>
		</nav>
		<main role="main">
		<!--Weave of 'Scenes' generated by Inweb-->
<div class="breadcrumbs">
    <ul class="crumbs"><li><a href="../index.html">Home</a></li><li><a href="../inform7n.html">Inform7</a></li><li><a href="index.html">if</a></li><li><a href="index.html#3">Chapter 3: Space and Time</a></li><li><b>Scenes</b></li></ul></div>
<p class="purpose">A feature to support named periods of time during an interactive story.</p>

<ul class="toc"><li><a href="3-scn.html#SP1">&#167;1. Introduction</a></li><li><a href="3-scn.html#SP10">&#167;10. Conceptual model of scenes</a></li><li><a href="3-scn.html#SP12">&#167;12. Scene structures</a></li><li><a href="3-scn.html#SP14">&#167;14. Creating and parsing ends</a></li><li><a href="3-scn.html#SP15">&#167;15. Tie the ends of a scene to a dialogue beat</a></li><li><a href="3-scn.html#SP16">&#167;16. Scene end rulebooks</a></li><li><a href="3-scn.html#SP17">&#167;17. Anchors</a></li><li><a href="3-scn.html#SP28">&#167;28. Rules predicated on scenes</a></li></ul><hr class="tocbar">

<p class="commentary firstcommentary"><a id="SP1" class="paragraph-anchor"></a><b>&#167;1. Introduction. </b>Scenes are periods of time during play: at any given moment, several may be
going on, or none. They are started and stopped when certain conditions are
met, or by virtue of having been anchored together.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Scenes::start</span><button class="popup" onclick="togglePopup('usagePopup1')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup1">Usage of <span class="code-font"><span class="function-syntax">Scenes::start</span></span>:<br/>IF Module - <a href="1-im.html#SP5">&#167;5</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">void</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><a href="3-scn.html#SP3" class="function-link"><span class="function-syntax">Scenes::declare_annotations</span></a><span class="plain-syntax">();</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">PluginCalls::plug</span><span class="plain-syntax">(</span><span class="identifier-syntax">NEW_PROPERTY_NOTIFY_PLUG</span><span class="plain-syntax">, </span><a href="3-scn.html#SP9" class="function-link"><span class="function-syntax">Scenes::new_property_notify</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">PluginCalls::plug</span><span class="plain-syntax">(</span><span class="identifier-syntax">NEW_INSTANCE_NOTIFY_PLUG</span><span class="plain-syntax">, </span><a href="3-scn.html#SP6" class="function-link"><span class="function-syntax">Scenes::new_named_instance_notify</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">PluginCalls::plug</span><span class="plain-syntax">(</span><span class="identifier-syntax">NEW_BASE_KIND_NOTIFY_PLUG</span><span class="plain-syntax">, </span><a href="3-scn.html#SP5" class="function-link"><span class="function-syntax">Scenes::new_base_kind_notify</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">PluginCalls::plug</span><span class="plain-syntax">(</span><span class="identifier-syntax">COMPARE_CONSTANT_PLUG</span><span class="plain-syntax">, </span><a href="3-scn.html#SP5" class="function-link"><span class="function-syntax">Scenes::compare_CONSTANT</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">PluginCalls::plug</span><span class="plain-syntax">(</span><span class="identifier-syntax">MAKE_SPECIAL_MEANINGS_PLUG</span><span class="plain-syntax">, </span><a href="3-scn.html#SP17" class="function-link"><span class="function-syntax">Scenes::make_special_meanings</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">PluginCalls::plug</span><span class="plain-syntax">(</span><span class="identifier-syntax">NEW_RCD_NOTIFY_PLUG</span><span class="plain-syntax">, </span><a href="3-scn.html#SP28" class="function-link"><span class="function-syntax">Scenes::new_rcd</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP2" class="paragraph-anchor"></a><b>&#167;2.  </b>This feature needs one extra syntax tree annotation:
</p>

<pre class="definitions code-font"><span class="definition-keyword">enum</span> <span class="constant-syntax">constant_scene_ANNOT</span><span class="plain-syntax"> </span><span class="comment-syntax"> </span><span class="extract"><span class="extract-syntax">scene</span></span><span class="comment-syntax">: for constant values</span>
</pre>
<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">DECLARE_ANNOTATION_FUNCTIONS</span><span class="plain-syntax">(</span><span class="identifier-syntax">constant_scene</span><span class="plain-syntax">, </span><span class="reserved-syntax">scene</span><span class="plain-syntax">)</span>
</pre>
<p class="commentary firstcommentary"><a id="SP3" class="paragraph-anchor"></a><b>&#167;3.  </b></p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">MAKE_ANNOTATION_FUNCTIONS</span><span class="plain-syntax">(</span><span class="identifier-syntax">constant_scene</span><span class="plain-syntax">, </span><span class="reserved-syntax">scene</span><span class="plain-syntax">)</span>

<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Scenes::declare_annotations</span><button class="popup" onclick="togglePopup('usagePopup2')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup2">Usage of <span class="code-font"><span class="function-syntax">Scenes::declare_annotations</span></span>:<br/><a href="3-scn.html#SP1">&#167;1</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">void</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Annotations::declare_type</span><span class="plain-syntax">(</span><span class="constant-syntax">constant_scene_ANNOT</span><span class="plain-syntax">, </span><a href="3-scn.html#SP3" class="function-link"><span class="function-syntax">Scenes::write_constant_scene_ANNOT</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Annotations::allow</span><span class="plain-syntax">(</span><span class="identifier-syntax">CONSTANT_NT</span><span class="plain-syntax">, </span><span class="constant-syntax">constant_scene_ANNOT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Scenes::write_constant_scene_ANNOT</span><span class="plain-syntax">(</span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">OUT</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Node::get_constant_scene</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">))</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">" {scene: %I}"</span><span class="plain-syntax">, </span><span class="identifier-syntax">Node::get_constant_scene</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">as_instance</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP4" class="paragraph-anchor"></a><b>&#167;4.  </b>Scenes are the instances of a built-in enumeration kind, created by a
Neptune file belonging to <a href="../WorldModelKit/index.html" class="internal">WorldModelKit</a>, and this is recognised by its
Inter identifier <span class="extract"><span class="extract-syntax">SCENE_TY</span></span>.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">K_scene</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
</pre>
<p class="commentary firstcommentary"><a id="SP5" class="paragraph-anchor"></a><b>&#167;5.  </b></p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">Scenes::new_base_kind_notify</span><button class="popup" onclick="togglePopup('usagePopup3')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup3">Usage of <span class="code-font"><span class="function-syntax">Scenes::new_base_kind_notify</span></span>:<br/><a href="3-scn.html#SP1">&#167;1</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">new_base</span><span class="plain-syntax">, </span><span class="identifier-syntax">text_stream</span><span class="plain-syntax"> *</span><span class="identifier-syntax">name</span><span class="plain-syntax">, </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::eq_wide_string</span><span class="plain-syntax">(</span><span class="identifier-syntax">name</span><span class="plain-syntax">, </span><span class="identifier-syntax">L</span><span class="string-syntax">"SCENE_TY"</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">K_scene</span><span class="plain-syntax"> = </span><span class="identifier-syntax">new_base</span><span class="plain-syntax">; </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>

<span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="function-syntax">Scenes::rvalue_from_scene</span><span class="plain-syntax">(</span><span class="reserved-syntax">scene</span><span class="plain-syntax"> *</span><span class="identifier-syntax">val</span><span class="plain-syntax">) { </span><span class="identifier-syntax">CONV_FROM</span><span class="plain-syntax">(</span><span class="reserved-syntax">scene</span><span class="plain-syntax">, </span><span class="identifier-syntax">K_scene</span><span class="plain-syntax">) }</span>
<span class="reserved-syntax">scene</span><span class="plain-syntax"> *</span><span class="function-syntax">Scenes::rvalue_to_scene</span><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec</span><span class="plain-syntax">) { </span><span class="identifier-syntax">CONV_TO</span><span class="plain-syntax">(</span><span class="reserved-syntax">scene</span><span class="plain-syntax">) }</span>

<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">Scenes::compare_CONSTANT</span><button class="popup" onclick="togglePopup('usagePopup4')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup4">Usage of <span class="code-font"><span class="function-syntax">Scenes::compare_CONSTANT</span></span>:<br/><a href="3-scn.html#SP1">&#167;1</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec1</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec2</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> *</span><span class="identifier-syntax">rv</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">K</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::get_kind_of_value</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec1</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Kinds::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">K</span><span class="plain-syntax">, </span><span class="identifier-syntax">K_scene</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="3-scn.html#SP5" class="function-link"><span class="function-syntax">Scenes::rvalue_to_scene</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec1</span><span class="plain-syntax">) == </span><a href="3-scn.html#SP5" class="function-link"><span class="function-syntax">Scenes::rvalue_to_scene</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec2</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            *</span><span class="identifier-syntax">rv</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        *</span><span class="identifier-syntax">rv</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP6" class="paragraph-anchor"></a><b>&#167;6.  </b><a href="3-scn.html#SP10" class="internal">scene</a> structures are automatically created whenever a new instance of the
kind "scene" is created, and this is where that happens.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">Scenes::new_named_instance_notify</span><button class="popup" onclick="togglePopup('usagePopup5')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup5">Usage of <span class="code-font"><span class="function-syntax">Scenes::new_named_instance_notify</span></span>:<br/><a href="3-scn.html#SP1">&#167;1</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">K_scene</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">Kinds::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">Instances::to_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">), </span><span class="identifier-syntax">K_scene</span><span class="plain-syntax">))) {</span>
<span class="plain-syntax">        </span><a href="3-scn.html#SP12" class="function-link"><span class="function-syntax">Scenes::new_scene</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP7" class="paragraph-anchor"></a><b>&#167;7.  </b>The following either/or property needs some compiler support:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">property</span><span class="plain-syntax"> *</span><span class="identifier-syntax">P_recurring</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
</pre>
<p class="commentary firstcommentary"><a id="SP8" class="paragraph-anchor"></a><b>&#167;8.  </b>This is a property name to do with scenes which Inform provides special
support for; it recognises the English name when it is defined by the
Standard Rules. (So there is no need to translate this to other languages.)
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;notable-scene-properties&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">recurring</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP9" class="paragraph-anchor"></a><b>&#167;9.  </b></p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">Scenes::new_property_notify</span><button class="popup" onclick="togglePopup('usagePopup6')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup6">Usage of <span class="code-font"><span class="function-syntax">Scenes::new_property_notify</span></span>:<br/><a href="3-scn.html#SP1">&#167;1</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">property</span><span class="plain-syntax"> *</span><span class="identifier-syntax">prn</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="function-syntax">&lt;notable-scene-properties&gt;(prn-&gt;</span><span class="element-syntax">name</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">switch</span><span class="plain-syntax"> (</span><span class="function-syntax">&lt;&lt;r&gt;&gt;</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="constant-syntax">0</span><span class="plain-syntax">: </span><span class="identifier-syntax">P_recurring</span><span class="plain-syntax"> = </span><span class="identifier-syntax">prn</span><span class="plain-syntax">; </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP10" class="paragraph-anchor"></a><b>&#167;10. Conceptual model of scenes. </b>Scenes are gated intervals of time, but there are more than two gates: for
while there is only one past, there are many possible futures. These gates
are called "ends" in the code below, and are numbered end 0 (the beginning),
end 1 (the usual end), and then any named ends ("ends badly" or "ends
triumphantly", for instance, might be ends 2 and 3). Each end has a condition
which can cause it, or can be "anchored" to any number of ends of other
scenes &mdash; to express which, the <a href="3-scn.html#SP10" class="internal">scene_connector</a> structure is used.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">typedef</span><span class="plain-syntax"> </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">scene</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">as_instance</span><span class="plain-syntax">; </span><span class="comment-syntax"> the constant for the name of the scene</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">once_only</span><span class="plain-syntax">; </span><span class="comment-syntax"> cannot repeat during play</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">start_of_play</span><span class="plain-syntax">; </span><span class="comment-syntax"> if begins when play begins</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">marker</span><span class="plain-syntax">; </span><span class="comment-syntax"> used to detect potentially infinite recursion when scene changes occur</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">no_ends</span><span class="plain-syntax">; </span><span class="comment-syntax"> how many ends the scene has</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">scene_end</span><span class="plain-syntax"> </span><span class="identifier-syntax">ends</span><span class="plain-syntax">[</span><span class="identifier-syntax">MAX_SCENE_ENDS</span><span class="plain-syntax">];</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">indexed</span><span class="plain-syntax">; </span><span class="comment-syntax"> temporary storage during Scenes index creation</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">CLASS_DEFINITION</span>
<span class="plain-syntax">} </span><span class="reserved-syntax">scene</span><span class="plain-syntax">;</span>

<span class="reserved-syntax">typedef</span><span class="plain-syntax"> </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">scene_end</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">end_names</span><span class="plain-syntax">; </span><span class="comment-syntax"> for ends 2, 3, ...: e.g. "badly"</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">rulebook</span><span class="plain-syntax"> *</span><span class="identifier-syntax">end_rulebook</span><span class="plain-syntax">; </span><span class="comment-syntax"> rules to apply then</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">dialogue_beat</span><span class="plain-syntax"> *</span><span class="identifier-syntax">as_beat</span><span class="plain-syntax">; </span><span class="comment-syntax"> only for those scenes equated to beats</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">anchor_condition</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">scene_connector</span><span class="plain-syntax"> *</span><span class="identifier-syntax">anchor_connectors</span><span class="plain-syntax">; </span><span class="comment-syntax"> linked list</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">anchor_condition_set</span><span class="plain-syntax">; </span><span class="comment-syntax"> where set</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">CLASS_DEFINITION</span>
<span class="plain-syntax">} </span><span class="reserved-syntax">scene_end</span><span class="plain-syntax">;</span>

<span class="reserved-syntax">typedef</span><span class="plain-syntax"> </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">scene_connector</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">scene</span><span class="plain-syntax"> *</span><span class="identifier-syntax">connect_to</span><span class="plain-syntax">; </span><span class="comment-syntax"> scene connected to</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">end</span><span class="plain-syntax">; </span><span class="comment-syntax"> end number: see above</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">scene_connector</span><span class="plain-syntax"> *</span><span class="identifier-syntax">next</span><span class="plain-syntax">; </span><span class="comment-syntax"> next in list of connectors for a scene end</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">where_said</span><span class="plain-syntax">; </span><span class="comment-syntax"> where this linkage was specified in source</span>
<span class="plain-syntax">} </span><span class="reserved-syntax">scene_connector</span><span class="plain-syntax">;</span>

<span class="reserved-syntax">scene</span><span class="plain-syntax"> *</span><span class="identifier-syntax">SC_entire_game</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>

<span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="function-syntax">Scenes::get_name</span><span class="plain-syntax">(</span><span class="reserved-syntax">scene</span><span class="plain-syntax"> *</span><span class="identifier-syntax">sc</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">Instances::get_name</span><span class="plain-syntax">(</span><span class="identifier-syntax">sc</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">as_instance</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>

<span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="function-syntax">Scenes::get_instance</span><span class="plain-syntax">(</span><span class="reserved-syntax">scene</span><span class="plain-syntax"> *</span><span class="identifier-syntax">sc</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">sc</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">as_instance</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>The structure scene is accessed in 6/dlg, 6/db, 6/dl, 6/dc, 6/ps and here.</li><li>The structure scene_end is private to this section.</li><li>The structure scene_connector is accessed in 2/ri, 3/tm, 3/ts, 3/mhr, 4/ap, 4/av, 4/apc, 5/us, 6/db, 6/dl, 6/dc and here.</li></ul>
<p class="commentary firstcommentary"><a id="SP11" class="paragraph-anchor"></a><b>&#167;11.  </b>A feature called <span class="extract"><span class="extract-syntax">xyzzy</span></span> generally has a hunk of subject data called <span class="extract"><span class="extract-syntax">xyzzy_data</span></span>,
so we would normally have a structure called <span class="extract"><span class="extract-syntax">scenes_data</span></span>, but in fact that
structure is just going to be <a href="3-scn.html#SP10" class="internal">scene</a>. So:
</p>

<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="constant-syntax">scenes_data</span><span class="plain-syntax"> </span><span class="reserved-syntax">scene</span>
<span class="definition-keyword">define</span> <span class="identifier-syntax">SCENES_DATA</span><span class="plain-syntax">(</span><span class="identifier-syntax">subj</span><span class="plain-syntax">) </span><span class="identifier-syntax">FEATURE_DATA_ON_SUBJECT</span><span class="plain-syntax">(</span><span class="identifier-syntax">scenes</span><span class="plain-syntax">, </span><span class="identifier-syntax">subj</span><span class="plain-syntax">)</span>
</pre>
<p class="commentary firstcommentary"><a id="SP12" class="paragraph-anchor"></a><b>&#167;12. Scene structures. </b>As we've seen, the following is called whenever a new instance of "scene"
is created:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Scenes::new_scene</span><button class="popup" onclick="togglePopup('usagePopup7')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup7">Usage of <span class="code-font"><span class="function-syntax">Scenes::new_scene</span></span>:<br/><a href="3-scn.html#SP6">&#167;6</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">scene</span><span class="plain-syntax"> *</span><span class="identifier-syntax">sc</span><span class="plain-syntax"> = </span><span class="identifier-syntax">CREATE</span><span class="plain-syntax">(</span><span class="reserved-syntax">scene</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="3-scn.html#SP12_3" class="named-paragraph-link"><span class="named-paragraph">Connect the scene structure to the instance</span><span class="named-paragraph-number">12.3</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="3-scn.html#SP12_1" class="named-paragraph-link"><span class="named-paragraph">Initialise the scene structure</span><span class="named-paragraph-number">12.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP12_1" class="paragraph-anchor"></a><b>&#167;12.1.  </b>A scene begins with two ends, 0 (beginning) and 1 (standard end).
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Initialise the scene structure</span><span class="named-paragraph-number">12.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">sc</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">once_only</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">sc</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">indexed</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">sc</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">no_ends</span><span class="plain-syntax"> = </span><span class="constant-syntax">2</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">sc</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">start_of_play</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">end</span><span class="plain-syntax">=0; </span><span class="identifier-syntax">end</span><span class="function-syntax">&lt;sc-&gt;</span><span class="element-syntax">no_ends</span><span class="plain-syntax">; </span><span class="identifier-syntax">end</span><span class="plain-syntax">++) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">sc</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">ends</span><span class="plain-syntax">[</span><span class="identifier-syntax">end</span><span class="plain-syntax">].</span><span class="element-syntax">anchor_condition</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">sc</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">ends</span><span class="plain-syntax">[</span><span class="identifier-syntax">end</span><span class="plain-syntax">].</span><span class="element-syntax">as_beat</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">sc</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">ends</span><span class="plain-syntax">[</span><span class="identifier-syntax">end</span><span class="plain-syntax">].</span><span class="element-syntax">anchor_connectors</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><a href="3-scn.html#SP16" class="function-link"><span class="function-syntax">Scenes::new_scene_rulebook</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">sc</span><span class="plain-syntax">, </span><span class="identifier-syntax">end</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-scn.html#SP12">&#167;12</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP12_2" class="paragraph-anchor"></a><b>&#167;12.2.  </b>This is a scene name which Inform provides special support for; it recognises
the English name when it is defined by the Standard Rules. (So there is no need
to translate this to other languages.)
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;notable-scenes&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">entire</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">game</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP12_3" class="paragraph-anchor"></a><b>&#167;12.3.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Connect the scene structure to the instance</span><span class="named-paragraph-number">12.3</span></span><span class="Preform-comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">sc</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">as_instance</span><span class="plain-syntax"> = </span><span class="identifier-syntax">I</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">ATTACH_FEATURE_DATA_TO_SUBJECT</span><span class="plain-syntax">(</span><span class="identifier-syntax">scenes</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">as_subject</span><span class="plain-syntax">, </span><span class="identifier-syntax">sc</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Instances::get_name</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="function-syntax">&lt;notable-scenes&gt;</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">)) </span><span class="identifier-syntax">SC_entire_game</span><span class="plain-syntax"> = </span><span class="identifier-syntax">sc</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-scn.html#SP12">&#167;12</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP13" class="paragraph-anchor"></a><b>&#167;13.  </b>So we sometimes want to be able to get from an instance to its scene structure.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">scene</span><span class="plain-syntax"> *</span><span class="function-syntax">Scenes::from_named_constant</span><button class="popup" onclick="togglePopup('usagePopup8')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup8">Usage of <span class="code-font"><span class="function-syntax">Scenes::from_named_constant</span></span>:<br/><a href="3-scn.html#SP24_1">&#167;24.1</a>, <a href="3-scn.html#SP29">&#167;29</a><br/>Dialogue Beats - <a href="6-db.html#SP5">&#167;5</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">K_scene</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> *</span><span class="identifier-syntax">K</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Instances::to_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Kinds::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">K</span><span class="plain-syntax">, </span><span class="identifier-syntax">K_scene</span><span class="plain-syntax">)) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FEATURE_DATA_ON_SUBJECT</span><span class="plain-syntax">(</span><span class="identifier-syntax">scenes</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">as_subject</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>

<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">Scenes::is_entire_game</span><span class="plain-syntax">(</span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">SC_entire_game</span><span class="plain-syntax">) &amp;&amp; (</span><a href="3-scn.html#SP13" class="function-link"><span class="function-syntax">Scenes::from_named_constant</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">) == </span><span class="identifier-syntax">SC_entire_game</span><span class="plain-syntax">))</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP14" class="paragraph-anchor"></a><b>&#167;14. Creating and parsing ends. </b></p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">Scenes::parse_scene_end_name</span><button class="popup" onclick="togglePopup('usagePopup9')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup9">Usage of <span class="code-font"><span class="function-syntax">Scenes::parse_scene_end_name</span></span>:<br/><a href="3-scn.html#SP25">&#167;25</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">scene</span><span class="plain-syntax"> *</span><span class="identifier-syntax">sc</span><span class="plain-syntax">, </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">EW</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">create</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">i</span><span class="plain-syntax">=2; </span><span class="identifier-syntax">i</span><span class="function-syntax">&lt;sc-&gt;</span><span class="element-syntax">no_ends</span><span class="plain-syntax">; </span><span class="identifier-syntax">i</span><span class="plain-syntax">++)</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Wordings::match</span><span class="plain-syntax">(</span><span class="identifier-syntax">EW</span><span class="plain-syntax">, </span><span class="identifier-syntax">sc</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">ends</span><span class="plain-syntax">[</span><span class="identifier-syntax">i</span><span class="plain-syntax">].</span><span class="element-syntax">end_names</span><span class="plain-syntax">))</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">i</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">create</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">end</span><span class="plain-syntax"> = </span><span class="identifier-syntax">sc</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">no_ends</span><span class="plain-syntax">++;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">max</span><span class="plain-syntax"> = </span><span class="constant-syntax">31</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">TargetVMs::is_16_bit</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::vm</span><span class="plain-syntax">())) </span><span class="identifier-syntax">max</span><span class="plain-syntax"> = </span><span class="constant-syntax">15</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">end</span><span class="plain-syntax"> &gt;= </span><span class="identifier-syntax">max</span><span class="plain-syntax">) </span><span class="named-paragraph-container code-font"><a href="3-scn.html#SP14_1" class="named-paragraph-link"><span class="named-paragraph">Issue a too-many-ends problem message</span><span class="named-paragraph-number">14.1</span></a></span>
<span class="plain-syntax">        </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">sc</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">ends</span><span class="plain-syntax">[</span><span class="identifier-syntax">end</span><span class="plain-syntax">].</span><span class="element-syntax">end_names</span><span class="plain-syntax"> = </span><span class="identifier-syntax">EW</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><a href="3-scn.html#SP16" class="function-link"><span class="function-syntax">Scenes::new_scene_rulebook</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">sc</span><span class="plain-syntax">, </span><span class="identifier-syntax">end</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">end</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> -1;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP14_1" class="paragraph-anchor"></a><b>&#167;14.1.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Issue a too-many-ends problem message</span><span class="named-paragraph-number">14.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_ScenesWithTooManyEnds</span><span class="plain-syntax">),</span>
<span class="plain-syntax">        </span><span class="string-syntax">"this scene now has too many different ways to end"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"and will need to be simplified. (We can have up to 15 ends to a scene "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"if the project format is for the Z-machine, and 31 for Glulx: see the "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"project's Settings panel. Note that the ordinary 'begins' and 'ends' "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"count as two of those, so you can only name up to 13 or 29 more specific "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"ways for the scene to end.)"</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-scn.html#SP14">&#167;14</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP15" class="paragraph-anchor"></a><b>&#167;15. Tie the ends of a scene to a dialogue beat. </b></p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Scenes::set_beat</span><button class="popup" onclick="togglePopup('usagePopup10')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup10">Usage of <span class="code-font"><span class="function-syntax">Scenes::set_beat</span></span>:<br/>Dialogue Beats - <a href="6-db.html#SP5">&#167;5</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">scene</span><span class="plain-syntax"> *</span><span class="identifier-syntax">sc</span><span class="plain-syntax">, </span><span class="reserved-syntax">dialogue_beat</span><span class="plain-syntax"> *</span><span class="identifier-syntax">db</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">sc</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">ends</span><span class="plain-syntax">[0].</span><span class="element-syntax">as_beat</span><span class="plain-syntax"> = </span><span class="identifier-syntax">db</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">sc</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">ends</span><span class="plain-syntax">[1].</span><span class="element-syntax">as_beat</span><span class="plain-syntax"> = </span><span class="identifier-syntax">db</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP16" class="paragraph-anchor"></a><b>&#167;16. Scene end rulebooks. </b></p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Scenes::new_scene_rulebook</span><button class="popup" onclick="togglePopup('usagePopup11')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup11">Usage of <span class="code-font"><span class="function-syntax">Scenes::new_scene_rulebook</span></span>:<br/><a href="3-scn.html#SP12_1">&#167;12.1</a>, <a href="3-scn.html#SP14">&#167;14</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">scene</span><span class="plain-syntax"> *</span><span class="identifier-syntax">sc</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">end</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">RW</span><span class="plain-syntax"> = </span><span class="identifier-syntax">EMPTY_WORDING</span><span class="plain-syntax">, </span><span class="identifier-syntax">AW</span><span class="plain-syntax"> = </span><span class="identifier-syntax">EMPTY_WORDING</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="3-scn.html#SP16_1" class="named-paragraph-link"><span class="named-paragraph">Compose a name and alternate name for the new scene end rulebook</span><span class="named-paragraph-number">16.1</span></a></span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">rulebook</span><span class="plain-syntax"> *</span><span class="identifier-syntax">rb</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Rulebooks::new_automatic</span><span class="plain-syntax">(</span><span class="identifier-syntax">RW</span><span class="plain-syntax">, </span><span class="identifier-syntax">K_action_name</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">NO_OUTCOME</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="constant-syntax">0</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Rulebooks::set_alt_name</span><span class="plain-syntax">(</span><span class="identifier-syntax">rb</span><span class="plain-syntax">, </span><span class="identifier-syntax">AW</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">sc</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">ends</span><span class="plain-syntax">[</span><span class="identifier-syntax">end</span><span class="plain-syntax">].</span><span class="element-syntax">end_rulebook</span><span class="plain-syntax"> = </span><span class="identifier-syntax">rb</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">end</span><span class="plain-syntax"> &gt;= </span><span class="constant-syntax">2</span><span class="plain-syntax">) </span><span class="named-paragraph-container code-font"><a href="3-scn.html#SP16_2" class="named-paragraph-link"><span class="named-paragraph">Define phrases detecting whether or not the scene has ended this way</span><span class="named-paragraph-number">16.2</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP16_1" class="paragraph-anchor"></a><b>&#167;16.1.  </b>For example, if a scene is called "Banquet Entertainment" and it ends
"merrily", then the rulebook has two names: "when Banquet Entertainment
ends merrily" and "when the Banquet Entertainment ends merrily".
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Compose a name and alternate name for the new scene end rulebook</span><span class="named-paragraph-number">16.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">NW</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Instances::get_name</span><span class="plain-syntax">(</span><span class="identifier-syntax">sc</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">as_instance</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">feed_t</span><span class="plain-syntax"> </span><span class="identifier-syntax">id</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Feeds::begin</span><span class="plain-syntax">();</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Feeds::feed_C_string_expanding_strings</span><span class="plain-syntax">(</span><span class="identifier-syntax">L</span><span class="string-syntax">"when"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Feeds::feed_wording</span><span class="plain-syntax">(</span><span class="identifier-syntax">NW</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Feeds::feed_C_string_expanding_strings</span><span class="plain-syntax">((</span><span class="identifier-syntax">end</span><span class="plain-syntax">==0)?</span><span class="identifier-syntax">L</span><span class="string-syntax">"begins"</span><span class="plain-syntax">:</span><span class="identifier-syntax">L</span><span class="string-syntax">"ends"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">end</span><span class="plain-syntax"> &gt;= </span><span class="constant-syntax">2</span><span class="plain-syntax">) </span><span class="identifier-syntax">Feeds::feed_wording</span><span class="plain-syntax">(</span><span class="identifier-syntax">sc</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">ends</span><span class="plain-syntax">[</span><span class="identifier-syntax">end</span><span class="plain-syntax">].</span><span class="element-syntax">end_names</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">RW</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Feeds::end</span><span class="plain-syntax">(</span><span class="identifier-syntax">id</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">id</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Feeds::begin</span><span class="plain-syntax">();</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Feeds::feed_C_string_expanding_strings</span><span class="plain-syntax">(</span><span class="identifier-syntax">L</span><span class="string-syntax">"when the"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">NW</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Instances::get_name</span><span class="plain-syntax">(</span><span class="identifier-syntax">sc</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">as_instance</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Feeds::feed_wording</span><span class="plain-syntax">(</span><span class="identifier-syntax">NW</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Feeds::feed_C_string_expanding_strings</span><span class="plain-syntax">((</span><span class="identifier-syntax">end</span><span class="plain-syntax">==0)?</span><span class="identifier-syntax">L</span><span class="string-syntax">"begins"</span><span class="plain-syntax">:</span><span class="identifier-syntax">L</span><span class="string-syntax">"ends"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">end</span><span class="plain-syntax"> &gt;= </span><span class="constant-syntax">2</span><span class="plain-syntax">) </span><span class="identifier-syntax">Feeds::feed_wording</span><span class="plain-syntax">(</span><span class="identifier-syntax">sc</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">ends</span><span class="plain-syntax">[</span><span class="identifier-syntax">end</span><span class="plain-syntax">].</span><span class="element-syntax">end_names</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">AW</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Feeds::end</span><span class="plain-syntax">(</span><span class="identifier-syntax">id</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-scn.html#SP16">&#167;16</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP16_2" class="paragraph-anchor"></a><b>&#167;16.2.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Define phrases detecting whether or not the scene has ended this way</span><span class="named-paragraph-number">16.2</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">NW</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Instances::get_name</span><span class="plain-syntax">(</span><span class="identifier-syntax">sc</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">as_instance</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">TEMPORARY_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">i6_code</span><span class="plain-syntax">)</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">feed_t</span><span class="plain-syntax"> </span><span class="identifier-syntax">id</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Feeds::begin</span><span class="plain-syntax">();</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Feeds::feed_C_string_expanding_strings</span><span class="plain-syntax">(</span><span class="identifier-syntax">L</span><span class="string-syntax">"To decide if (S - "</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Feeds::feed_wording</span><span class="plain-syntax">(</span><span class="identifier-syntax">NW</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Feeds::feed_C_string_expanding_strings</span><span class="plain-syntax">(</span><span class="identifier-syntax">L</span><span class="string-syntax">") ended "</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Feeds::feed_wording</span><span class="plain-syntax">(</span><span class="identifier-syntax">sc</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">ends</span><span class="plain-syntax">[</span><span class="identifier-syntax">end</span><span class="plain-syntax">].</span><span class="element-syntax">end_names</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Sentences::make_node</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">Feeds::end</span><span class="plain-syntax">(</span><span class="identifier-syntax">id</span><span class="plain-syntax">), </span><span class="character-syntax">':'</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">id</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Feeds::begin</span><span class="plain-syntax">();</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Str::clear</span><span class="plain-syntax">(</span><span class="identifier-syntax">i6_code</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">i6_code</span><span class="plain-syntax">, </span><span class="string-syntax">" (- (scene_latest_ending--&gt;%d == %d) -) "</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">sc</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">allocation_id</span><span class="plain-syntax">, </span><span class="identifier-syntax">end</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Feeds::feed_text_expanding_strings</span><span class="plain-syntax">(</span><span class="identifier-syntax">i6_code</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Sentences::make_node</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">Feeds::end</span><span class="plain-syntax">(</span><span class="identifier-syntax">id</span><span class="plain-syntax">), </span><span class="character-syntax">'.'</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">id</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Feeds::begin</span><span class="plain-syntax">();</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Feeds::feed_C_string_expanding_strings</span><span class="plain-syntax">(</span><span class="identifier-syntax">L</span><span class="string-syntax">"To decide if (S - "</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Feeds::feed_wording</span><span class="plain-syntax">(</span><span class="identifier-syntax">NW</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Feeds::feed_C_string_expanding_strings</span><span class="plain-syntax">(</span><span class="identifier-syntax">L</span><span class="string-syntax">") did not end "</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Feeds::feed_wording</span><span class="plain-syntax">(</span><span class="identifier-syntax">sc</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">ends</span><span class="plain-syntax">[</span><span class="identifier-syntax">end</span><span class="plain-syntax">].</span><span class="element-syntax">end_names</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Sentences::make_node</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">Feeds::end</span><span class="plain-syntax">(</span><span class="identifier-syntax">id</span><span class="plain-syntax">), </span><span class="character-syntax">':'</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">id</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Feeds::begin</span><span class="plain-syntax">();</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Str::clear</span><span class="plain-syntax">(</span><span class="identifier-syntax">i6_code</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">i6_code</span><span class="plain-syntax">, </span><span class="string-syntax">" (- (scene_latest_ending--&gt;%d ~= 0 or %d) -) "</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">sc</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">allocation_id</span><span class="plain-syntax">, </span><span class="identifier-syntax">end</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Feeds::feed_text_expanding_strings</span><span class="plain-syntax">(</span><span class="identifier-syntax">i6_code</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Sentences::make_node</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">Feeds::end</span><span class="plain-syntax">(</span><span class="identifier-syntax">id</span><span class="plain-syntax">), </span><span class="character-syntax">'.'</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">ImperativeSubtrees::accept_all</span><span class="plain-syntax">();</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">DISCARD_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">i6_code</span><span class="plain-syntax">)</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-scn.html#SP16">&#167;16</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP17" class="paragraph-anchor"></a><b>&#167;17. Anchors. </b>These are joins between the endings of different scenes, and there are two
assertion sentences to create them:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">Scenes::make_special_meanings</span><button class="popup" onclick="togglePopup('usagePopup12')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup12">Usage of <span class="code-font"><span class="function-syntax">Scenes::make_special_meanings</span></span>:<br/><a href="3-scn.html#SP1">&#167;1</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">void</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">SpecialMeanings::declare</span><span class="plain-syntax">(</span><a href="3-scn.html#SP18" class="function-link"><span class="function-syntax">Scenes::begins_when_SMF</span></a><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"scene-begins-when"</span><span class="plain-syntax">, </span><span class="constant-syntax">1</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">SpecialMeanings::declare</span><span class="plain-syntax">(</span><a href="3-scn.html#SP19" class="function-link"><span class="function-syntax">Scenes::ends_when_SMF</span></a><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"scene-ends-when"</span><span class="plain-syntax">, </span><span class="constant-syntax">1</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP18" class="paragraph-anchor"></a><b>&#167;18.  </b>This one handles the special meaning "X begins when...".
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">Scenes::begins_when_SMF</span><button class="popup" onclick="togglePopup('usagePopup13')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup13">Usage of <span class="code-font"><span class="function-syntax">Scenes::begins_when_SMF</span></span>:<br/><a href="3-scn.html#SP17">&#167;17</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">task</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">V</span><span class="plain-syntax">, </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> *</span><span class="identifier-syntax">NPs</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">SW</span><span class="plain-syntax"> = (</span><span class="identifier-syntax">NPs</span><span class="plain-syntax">)?(</span><span class="identifier-syntax">NPs</span><span class="plain-syntax">[0]):</span><span class="identifier-syntax">EMPTY_WORDING</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">OW</span><span class="plain-syntax"> = (</span><span class="identifier-syntax">NPs</span><span class="plain-syntax">)?(</span><span class="identifier-syntax">NPs</span><span class="plain-syntax">[1]):</span><span class="identifier-syntax">EMPTY_WORDING</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">switch</span><span class="plain-syntax"> (</span><span class="identifier-syntax">task</span><span class="plain-syntax">) { </span><span class="comment-syntax"> "The Ballroom Scene begins when..."</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">ACCEPT_SMFT:</span>
<span class="plain-syntax">            </span><span class="function-syntax">&lt;np-unparsed&gt;</span><span class="plain-syntax">(</span><span class="identifier-syntax">OW</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">O</span><span class="plain-syntax"> = </span><span class="function-syntax">&lt;&lt;rp&gt;&gt;</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="function-syntax">&lt;np-unparsed&gt;</span><span class="plain-syntax">(</span><span class="identifier-syntax">SW</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">V</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax"> = </span><span class="function-syntax">&lt;&lt;rp&gt;&gt;</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">V</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax"> = </span><span class="identifier-syntax">O</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">PASS_1_SMFT:</span>
<span class="plain-syntax">            </span><a href="3-scn.html#SP26" class="function-link"><span class="function-syntax">Scenes::new_scene_anchor</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">V</span><span class="plain-syntax">, </span><span class="constant-syntax">1</span><span class="plain-syntax">, </span><span class="constant-syntax">0</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">PASS_2_SMFT:</span>
<span class="plain-syntax">            </span><a href="3-scn.html#SP26" class="function-link"><span class="function-syntax">Scenes::new_scene_anchor</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">V</span><span class="plain-syntax">, </span><span class="constant-syntax">2</span><span class="plain-syntax">, </span><span class="constant-syntax">0</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP19" class="paragraph-anchor"></a><b>&#167;19.  </b>This handles the special meaning "X ends when...", which sometimes takes
two noun phrases and sometimes three.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">Scenes::ends_when_SMF</span><button class="popup" onclick="togglePopup('usagePopup14')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup14">Usage of <span class="code-font"><span class="function-syntax">Scenes::ends_when_SMF</span></span>:<br/><a href="3-scn.html#SP17">&#167;17</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">task</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">V</span><span class="plain-syntax">, </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> *</span><span class="identifier-syntax">NPs</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">SW</span><span class="plain-syntax"> = (</span><span class="identifier-syntax">NPs</span><span class="plain-syntax">)?(</span><span class="identifier-syntax">NPs</span><span class="plain-syntax">[0]):</span><span class="identifier-syntax">EMPTY_WORDING</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">OW</span><span class="plain-syntax"> = (</span><span class="identifier-syntax">NPs</span><span class="plain-syntax">)?(</span><span class="identifier-syntax">NPs</span><span class="plain-syntax">[1]):</span><span class="identifier-syntax">EMPTY_WORDING</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">O2W</span><span class="plain-syntax"> = (</span><span class="identifier-syntax">NPs</span><span class="plain-syntax">)?(</span><span class="identifier-syntax">NPs</span><span class="plain-syntax">[2]):</span><span class="identifier-syntax">EMPTY_WORDING</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">switch</span><span class="plain-syntax"> (</span><span class="identifier-syntax">task</span><span class="plain-syntax">) { </span><span class="comment-syntax"> "The Ballroom Scene ends when..."</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">ACCEPT_SMFT:</span>
<span class="plain-syntax">            </span><span class="function-syntax">&lt;np-unparsed&gt;</span><span class="plain-syntax">(</span><span class="identifier-syntax">OW</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">O</span><span class="plain-syntax"> = </span><span class="function-syntax">&lt;&lt;rp&gt;&gt;</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="function-syntax">&lt;np-unparsed&gt;</span><span class="plain-syntax">(</span><span class="identifier-syntax">SW</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">V</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax"> = </span><span class="function-syntax">&lt;&lt;rp&gt;&gt;</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Wordings::nonempty</span><span class="plain-syntax">(</span><span class="identifier-syntax">O2W</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">                </span><span class="function-syntax">&lt;np-unparsed&gt;</span><span class="plain-syntax">(</span><span class="identifier-syntax">O2W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">V</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax"> = </span><span class="function-syntax">&lt;&lt;rp&gt;&gt;</span><span class="plain-syntax">;</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">V</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax"> = </span><span class="identifier-syntax">O</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">V</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax"> = </span><span class="identifier-syntax">O</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            }</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">PASS_1_SMFT:</span>
<span class="plain-syntax">            </span><a href="3-scn.html#SP26" class="function-link"><span class="function-syntax">Scenes::new_scene_anchor</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">V</span><span class="plain-syntax">, </span><span class="constant-syntax">1</span><span class="plain-syntax">, </span><span class="constant-syntax">1</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">case</span><span class="plain-syntax"> </span><span class="identifier-syntax">PASS_2_SMFT:</span>
<span class="plain-syntax">            </span><a href="3-scn.html#SP26" class="function-link"><span class="function-syntax">Scenes::new_scene_anchor</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">V</span><span class="plain-syntax">, </span><span class="constant-syntax">2</span><span class="plain-syntax">, </span><span class="constant-syntax">1</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP20" class="paragraph-anchor"></a><b>&#167;20.  </b>This rather clumsy global variable is a convenience when parsing the
Preform grammar below.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">scene</span><span class="plain-syntax"> *</span><span class="identifier-syntax">scene_end_of_which_parsed</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
</pre>
<p class="commentary firstcommentary"><a id="SP21" class="paragraph-anchor"></a><b>&#167;21.  </b>Sentences giving scene boundaries have a simple form:
</p>

<blockquote>
    <p>The Ballroom Dance begins when the Hallway Greeting ends.</p>
</blockquote>

<blockquote>
    <p>The Ballroom Dance ends dramatically when we have dropped the glass slipper.</p>
</blockquote>

<p class="commentary">The sentence has a subject noun phrase (here "Ballroom Dance") and an
object NP: "the Hallway Greeting ends" or "we have dropped the glass
slipper" are the object NPs here. We will call the optional part,
"dramatically" in this example, the adverb, though it doesn't actually
have to be worded as one.
</p>

<p class="commentary">The subject is simple: it has to be a scene name.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;scene-ends-sentence-subject&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;scene-name&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { TRUE, RP[1] }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">...</span><span class="Preform-plain-syntax">             </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="3-scn.html#SP21_1" class="named-paragraph-link"><span class="named-paragraph">Issue PM_ScenesOnly problem</span><span class="named-paragraph-number">21.1</span></a></span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP21_1" class="paragraph-anchor"></a><b>&#167;21.1.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Issue PM_ScenesOnly problem</span><span class="named-paragraph-number">21.1</span></span><span class="Preform-comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_ScenesOnly</span><span class="plain-syntax">),</span>
<span class="plain-syntax">        </span><span class="string-syntax">"'begins when' and 'ends when' can only be applied to scenes"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"which have already been defined with a sentence like 'The final "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"confrontation is a scene.'"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    ==&gt; { </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax"> };</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-scn.html#SP21">&#167;21</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP22" class="paragraph-anchor"></a><b>&#167;22.  </b>The adverb, if present, always matches, since the scene end is created
if it doesn't already exist:
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;scene-ends-sentence-adverb&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;scene-end-name-creating&gt;</span><span class="Preform-plain-syntax">               </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP23" class="paragraph-anchor"></a><b>&#167;23.  </b>The following is elementary enough, but we want to be careful because
there are possible ambiguities: the condition might contain the word "ends"
in a different context, for instance, and could still be valid in that case.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;scene-ends-sentence-object&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;text-including-a-calling&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">          </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="3-scn.html#SP23_1" class="named-paragraph-link"><span class="named-paragraph">Issue PM_ScenesDisallowCalled problem</span><span class="named-paragraph-number">23.1</span></a></span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">play</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">begins</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                         </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -1, - }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-constant-syntax">play</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">ends</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                           </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="3-scn.html#SP23_2" class="named-paragraph-link"><span class="named-paragraph">Issue PM_ScenesNotPlay problem</span><span class="named-paragraph-number">23.2</span></a></span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;scene-name&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">begins</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                 </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { 0, -, &lt;&lt;scene:named&gt;&gt; = RP[1] }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;scene-name&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">ends</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">                   </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { 1, -, &lt;&lt;scene:named&gt;&gt; = RP[1] }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;scene-name&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">ends</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;scene-end-name&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">  </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { R[2], -, &lt;&lt;scene:named&gt;&gt; = RP[1] }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;scene-name&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">ends</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">...</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">               </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="3-scn.html#SP23_3" class="named-paragraph-link"><span class="named-paragraph">Issue PM_ScenesUnknownEnd problem</span><span class="named-paragraph-number">23.3</span></a></span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-condition&gt;</span><span class="Preform-plain-syntax">                         </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { -2, -, &lt;&lt;parse_node:cond&gt;&gt; = RP[1] }</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP23_1" class="paragraph-anchor"></a><b>&#167;23.1.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Issue PM_ScenesDisallowCalled problem</span><span class="named-paragraph-number">23.1</span></span><span class="Preform-comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_ScenesDisallowCalled</span><span class="plain-syntax">),</span>
<span class="plain-syntax">        </span><span class="string-syntax">"'(called ...)' is not allowed within conditions for a scene to begin or end"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"since calling gives only a temporary name to something, for the purpose "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"of further instructions which immediately follow in. Here there is no room "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"for such further instructions, so a calling would have no effect. Anyway - "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"not allowed!"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    ==&gt; { -1, - };</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-scn.html#SP23">&#167;23</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP23_2" class="paragraph-anchor"></a><b>&#167;23.2.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Issue PM_ScenesNotPlay problem</span><span class="named-paragraph-number">23.2</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_ScenesNotPlay</span><span class="plain-syntax">),</span>
<span class="plain-syntax">        </span><span class="string-syntax">"'play' is not really a scene"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"so although you can write '... when play begins' you cannot write '... "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"when play ends'. But there's no need to do so, anyway. When play ends, "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"all scenes end."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    ==&gt; { -1, - };</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-scn.html#SP23">&#167;23</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP23_3" class="paragraph-anchor"></a><b>&#167;23.3.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Issue PM_ScenesUnknownEnd problem</span><span class="named-paragraph-number">23.3</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_ScenesUnknownEnd</span><span class="plain-syntax">),</span>
<span class="plain-syntax">        </span><span class="string-syntax">"that's not one of the known ends for that scene"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="string-syntax">"which must be declared with something like 'Confrontation ends happily "</span>
<span class="plain-syntax">        </span><span class="string-syntax">"when...' or 'Confrontation ends tragically when...'."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    ==&gt; { -1, - };</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-scn.html#SP23">&#167;23</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP24" class="paragraph-anchor"></a><b>&#167;24.  </b>Where the following filters instance names to allow those of scenes only,
and also internally converts the result:
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;scene-name&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;definite-article&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-function-syntax">&lt;scene-name-unarticled&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">|</span><span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 2 }</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;scene-name-unarticled&gt;</span><span class="Preform-plain-syntax">                         </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> { pass 1 }</span>

<span class="Preform-function-syntax">&lt;scene-name-unarticled&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;instance-of-non-object&gt;</span><span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="3-scn.html#SP24_1" class="named-paragraph-link"><span class="named-paragraph">Convert instance result to scene result, if possible</span><span class="named-paragraph-number">24.1</span></a></span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP24_1" class="paragraph-anchor"></a><b>&#167;24.1.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Convert instance result to scene result, if possible</span><span class="named-paragraph-number">24.1</span></span><span class="Preform-comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax"> = </span><span class="function-syntax">&lt;&lt;rp&gt;&gt;</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Instances::of_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">, </span><span class="identifier-syntax">K_scene</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">scene_end_of_which_parsed</span><span class="plain-syntax"> = </span><a href="3-scn.html#SP13" class="function-link"><span class="function-syntax">Scenes::from_named_constant</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    ==&gt; { -, </span><span class="identifier-syntax">scene_end_of_which_parsed</span><span class="plain-syntax"> };</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-scn.html#SP24">&#167;24</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP25" class="paragraph-anchor"></a><b>&#167;25.  </b>Lastly, scene end names are parsed by these internals. They are identical
except that the creating case will create a new end if need be so that it
never fails.
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;scene-end-name&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">internal</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">int</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">end</span><span class="Preform-plain-syntax"> = </span><a href="3-scn.html#SP14" class="function-link"><span class="Preform-function-syntax">Scenes::parse_scene_end_name</span></a><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">scene_end_of_which_parsed</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">FALSE</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">if</span><span class="Preform-plain-syntax"> (</span><span class="Preform-identifier-syntax">end</span><span class="Preform-plain-syntax"> &lt; </span><span class="Preform-constant-syntax">0</span><span class="Preform-plain-syntax">) { ==&gt; { </span><span class="Preform-identifier-syntax">fail</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">nonterminal</span><span class="Preform-plain-syntax"> }; }</span>
<span class="Preform-plain-syntax">    ==&gt; { </span><span class="Preform-identifier-syntax">end</span><span class="Preform-plain-syntax">, - };</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">}</span>

<span class="Preform-function-syntax">&lt;scene-end-name-creating&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">internal</span><span class="Preform-plain-syntax"> </span><span class="Preform-constant-syntax">{</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">int</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">end</span><span class="Preform-plain-syntax"> = </span><a href="3-scn.html#SP14" class="function-link"><span class="Preform-function-syntax">Scenes::parse_scene_end_name</span></a><span class="Preform-plain-syntax">(</span><span class="Preform-identifier-syntax">scene_end_of_which_parsed</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">W</span><span class="Preform-plain-syntax">, </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">);</span>
<span class="Preform-plain-syntax">    ==&gt; { </span><span class="Preform-identifier-syntax">end</span><span class="Preform-plain-syntax">, - };</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-reserved-syntax">return</span><span class="Preform-plain-syntax"> </span><span class="Preform-identifier-syntax">TRUE</span><span class="Preform-plain-syntax">;</span>
<span class="Preform-plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP26" class="paragraph-anchor"></a><b>&#167;26.  </b>In a sentence like
</p>

<blockquote>
    <p>The Ballroom Dance begins when the Hallway Greeting ends.</p>
</blockquote>

<p class="commentary">we will call "the Ballroom Dance begins" this end, and "the Hallway Greeting
ends" the other end.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Scenes::new_scene_anchor</span><button class="popup" onclick="togglePopup('usagePopup15')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup15">Usage of <span class="code-font"><span class="function-syntax">Scenes::new_scene_anchor</span></span>:<br/><a href="3-scn.html#SP18">&#167;18</a>, <a href="3-scn.html#SP19">&#167;19</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">phase</span><span class="plain-syntax">, </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">given_end</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">scene</span><span class="plain-syntax"> *</span><span class="identifier-syntax">this_scene</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">; </span><span class="comment-syntax"> scene whose end is being caused: must be set</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">end</span><span class="plain-syntax"> = -1; </span><span class="comment-syntax"> end which is being anchored: must be set</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">scene</span><span class="plain-syntax"> *</span><span class="identifier-syntax">other_scene</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">; </span><span class="comment-syntax"> Either: another scene whose end it connects to</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">other_end</span><span class="plain-syntax"> = -1; </span><span class="comment-syntax"> and which end it is...</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">external_condition</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">; </span><span class="comment-syntax"> Or: an absolute condition...</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">when_play_begins</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">; </span><span class="comment-syntax"> Or: anchor to the start of play</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">SW</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">); </span><span class="comment-syntax"> scene name</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">EW</span><span class="plain-syntax"> = </span><span class="identifier-syntax">EMPTY_WORDING</span><span class="plain-syntax">; </span><span class="comment-syntax"> end name, if any</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">CW</span><span class="plain-syntax"> = </span><span class="identifier-syntax">EMPTY_WORDING</span><span class="plain-syntax">; </span><span class="comment-syntax"> condition for end to occur</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">next</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">EW</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">CW</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">CW</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">next</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>

<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="3-scn.html#SP26_4" class="named-paragraph-link"><span class="named-paragraph">Parse the scene and end to be anchored</span><span class="named-paragraph-number">26.4</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">this_scene</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) || (</span><span class="identifier-syntax">end</span><span class="plain-syntax"> &lt; </span><span class="constant-syntax">0</span><span class="plain-syntax">)) </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"scene misparsed"</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">phase</span><span class="plain-syntax"> == </span><span class="constant-syntax">2</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="named-paragraph-container code-font"><a href="3-scn.html#SP26_5" class="named-paragraph-link"><span class="named-paragraph">Parse which form of anchor we have</span><span class="named-paragraph-number">26.5</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">this_scene</span><span class="plain-syntax"> == </span><span class="identifier-syntax">SC_entire_game</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">external_condition</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(),</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_EntireGameHardwired</span><span class="plain-syntax">),</span>
<span class="plain-syntax">                </span><span class="string-syntax">"the special 'Entire Game' scene cannot have its start or end modified"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                </span><span class="string-syntax">"because it is a built-in scene designed to be going on whenever there "</span>
<span class="plain-syntax">                </span><span class="string-syntax">"is play going on in the story."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">when_play_begins</span><span class="plain-syntax">)</span>
<span class="plain-syntax">            </span><span class="named-paragraph-container code-font"><a href="3-scn.html#SP26_1" class="named-paragraph-link"><span class="named-paragraph">Connect this end to the start of play</span><span class="named-paragraph-number">26.1</span></a></span>
<span class="plain-syntax">        </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">other_scene</span><span class="plain-syntax">)</span>
<span class="plain-syntax">            </span><span class="named-paragraph-container code-font"><a href="3-scn.html#SP26_3" class="named-paragraph-link"><span class="named-paragraph">Connect this end to an end of another scene</span><span class="named-paragraph-number">26.3</span></a></span>
<span class="plain-syntax">        </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">external_condition</span><span class="plain-syntax">)</span>
<span class="plain-syntax">            </span><span class="named-paragraph-container code-font"><a href="3-scn.html#SP26_2" class="named-paragraph-link"><span class="named-paragraph">Make this an external scene end condition</span><span class="named-paragraph-number">26.2</span></a></span>
<span class="plain-syntax">        </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"failed to obtain an anchor condition"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP26_1" class="paragraph-anchor"></a><b>&#167;26.1.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Connect this end to the start of play</span><span class="named-paragraph-number">26.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">this_scene</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">start_of_play</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-scn.html#SP26">&#167;26</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP26_2" class="paragraph-anchor"></a><b>&#167;26.2.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Make this an external scene end condition</span><span class="named-paragraph-number">26.2</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">this_scene</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">ends</span><span class="plain-syntax">[</span><span class="identifier-syntax">end</span><span class="plain-syntax">].</span><span class="element-syntax">anchor_condition</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(),</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_ScenesOversetEnd</span><span class="plain-syntax">),</span>
<span class="plain-syntax">            </span><span class="string-syntax">"you have already told me a condition for when that happens"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="string-syntax">"and although a scene can be linked to the beginning or ending "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"of any number of other scenes, it can only have a single "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"condition such as 'when the player is in the Dining Car' "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"to trigger it from outside the scene machinery."</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">this_scene</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">ends</span><span class="plain-syntax">[</span><span class="identifier-syntax">end</span><span class="plain-syntax">].</span><span class="element-syntax">anchor_condition</span><span class="plain-syntax"> = </span><span class="identifier-syntax">external_condition</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">this_scene</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">ends</span><span class="plain-syntax">[</span><span class="identifier-syntax">end</span><span class="plain-syntax">].</span><span class="element-syntax">anchor_condition_set</span><span class="plain-syntax"> = </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-scn.html#SP26">&#167;26</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP26_3" class="paragraph-anchor"></a><b>&#167;26.3.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Connect this end to an end of another scene</span><span class="named-paragraph-number">26.3</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">scene_connector</span><span class="plain-syntax"> *</span><span class="identifier-syntax">scon</span><span class="plain-syntax"> = </span><span class="identifier-syntax">CREATE</span><span class="plain-syntax">(</span><span class="reserved-syntax">scene_connector</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">scon</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">connect_to</span><span class="plain-syntax"> = </span><span class="identifier-syntax">other_scene</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">scon</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">end</span><span class="plain-syntax"> = </span><span class="identifier-syntax">other_end</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">scon</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">where_said</span><span class="plain-syntax"> = </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">scon</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">next</span><span class="plain-syntax"> = </span><span class="identifier-syntax">this_scene</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">ends</span><span class="plain-syntax">[</span><span class="identifier-syntax">end</span><span class="plain-syntax">].</span><span class="element-syntax">anchor_connectors</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">this_scene</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">ends</span><span class="plain-syntax">[</span><span class="identifier-syntax">end</span><span class="plain-syntax">].</span><span class="element-syntax">anchor_connectors</span><span class="plain-syntax"> = </span><span class="identifier-syntax">scon</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-scn.html#SP26">&#167;26</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP26_4" class="paragraph-anchor"></a><b>&#167;26.4.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Parse the scene and end to be anchored</span><span class="named-paragraph-number">26.4</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="function-syntax">&lt;scene-ends-sentence-subject&gt;</span><span class="plain-syntax">(</span><span class="identifier-syntax">SW</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="function-syntax">&lt;&lt;r&gt;&gt;</span><span class="plain-syntax"> == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">this_scene</span><span class="plain-syntax"> = </span><span class="function-syntax">&lt;&lt;rp&gt;&gt;</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">scene_end_of_which_parsed</span><span class="plain-syntax"> = </span><span class="identifier-syntax">this_scene</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Wordings::nonempty</span><span class="plain-syntax">(</span><span class="identifier-syntax">EW</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="function-syntax">&lt;scene-ends-sentence-adverb&gt;</span><span class="plain-syntax">(</span><span class="identifier-syntax">EW</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">end</span><span class="plain-syntax"> = </span><span class="function-syntax">&lt;&lt;r&gt;&gt;</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="identifier-syntax">end</span><span class="plain-syntax"> = </span><span class="identifier-syntax">given_end</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">end</span><span class="plain-syntax"> &lt; </span><span class="constant-syntax">0</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax">; </span><span class="comment-syntax"> to recover from any parsing Problems</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-scn.html#SP26">&#167;26</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP26_5" class="paragraph-anchor"></a><b>&#167;26.5.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Parse which form of anchor we have</span><span class="named-paragraph-number">26.5</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="function-syntax">&lt;scene-ends-sentence-object&gt;</span><span class="plain-syntax">(</span><span class="identifier-syntax">CW</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">end</span><span class="plain-syntax"> = </span><span class="function-syntax">&lt;&lt;r&gt;&gt;</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">switch</span><span class="plain-syntax"> (</span><span class="identifier-syntax">end</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">case</span><span class="plain-syntax"> -2: </span><span class="identifier-syntax">external_condition</span><span class="plain-syntax"> = </span><span class="function-syntax">&lt;&lt;parse_node:cond&gt;&gt;</span><span class="plain-syntax">; </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">case</span><span class="plain-syntax"> -1: </span><span class="identifier-syntax">when_play_begins</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">; </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">default:</span><span class="plain-syntax"> </span><span class="identifier-syntax">other_end</span><span class="plain-syntax"> = </span><span class="identifier-syntax">end</span><span class="plain-syntax">; </span><span class="identifier-syntax">other_scene</span><span class="plain-syntax"> = </span><span class="function-syntax">&lt;&lt;scene:named&gt;&gt;</span><span class="plain-syntax">; </span><span class="reserved-syntax">break</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="identifier-syntax">external_condition</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Specifications::new_UNKNOWN</span><span class="plain-syntax">(</span><span class="identifier-syntax">CW</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-scn.html#SP26">&#167;26</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP27" class="paragraph-anchor"></a><b>&#167;27.  </b>One use of scenes is to kick off rulebooks when they begin or end. The other
use for them is to predicate rules on whether they are currently playing or
not, using a "during" clause, and this is used when parsing those in rule
headers. Note that a match here can name a specific scene, or describe a
collection of them:
</p>

<pre class="Preform-displayed-code all-displayed-code code-font">
<span class="Preform-function-syntax">&lt;s-scene-description&gt;</span><span class="Preform-plain-syntax"> </span><span class="Preform-reserved-syntax">::=</span>
<span class="Preform-plain-syntax">    </span><span class="Preform-function-syntax">&lt;s-value&gt;</span><span class="Preform-plain-syntax">       </span><span class="Preform-reserved-syntax">==&gt;</span><span class="Preform-plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="3-scn.html#SP27_1" class="named-paragraph-link"><span class="named-paragraph">Filter to force this to be a scene description</span><span class="named-paragraph-number">27.1</span></a></span>
</pre>
<ul class="endnotetexts"><li>This is <a href="../words-module/4-ap.html" class="internal">Preform grammar</a>, not regular C code.</li></ul>
<p class="commentary firstcommentary"><a id="SP27_1" class="paragraph-anchor"></a><b>&#167;27.1.  </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Filter to force this to be a scene description</span><span class="named-paragraph-number">27.1</span></span><span class="Preform-comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">K_scene</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec</span><span class="plain-syntax"> = </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[1];</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Rvalues::to_instance</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (((</span><span class="identifier-syntax">I</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">Instances::of_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">, </span><span class="identifier-syntax">K_scene</span><span class="plain-syntax">))) ||</span>
<span class="plain-syntax">        ((</span><span class="identifier-syntax">Specifications::is_description</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">)) &amp;&amp;</span>
<span class="plain-syntax">            (</span><span class="identifier-syntax">Kinds::eq</span><span class="plain-syntax">(</span><span class="identifier-syntax">Specifications::to_kind</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">), </span><span class="identifier-syntax">K_scene</span><span class="plain-syntax">)))) {</span>
<span class="plain-syntax">        ==&gt; { -, </span><span class="identifier-syntax">spec</span><span class="plain-syntax"> };</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-scn.html#SP27">&#167;27</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP28" class="paragraph-anchor"></a><b>&#167;28. Rules predicated on scenes. </b>Rules can be set to fire only during a certain scene, or a scene matching some
description. This is stored in the following scenes-feature corner of the
<a href="../assertions-module/5-rcd.html" class="internal">Runtime Context Data (in assertions)</a> for the rule:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">typedef</span><span class="plain-syntax"> </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="reserved-syntax">scenes_rcd_data</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">during_scene</span><span class="plain-syntax">; </span><span class="comment-syntax"> ...happens only during a scene matching this?</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">CLASS_DEFINITION</span>
<span class="plain-syntax">} </span><span class="reserved-syntax">scenes_rcd_data</span><span class="plain-syntax">;</span>

<span class="reserved-syntax">scenes_rcd_data</span><span class="plain-syntax"> *</span><span class="function-syntax">Scenes::new_rcd_data</span><span class="plain-syntax">(</span><span class="identifier-syntax">id_runtime_context_data</span><span class="plain-syntax"> *</span><span class="identifier-syntax">idrcd</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">scenes_rcd_data</span><span class="plain-syntax"> *</span><span class="identifier-syntax">srd</span><span class="plain-syntax"> = </span><span class="identifier-syntax">CREATE</span><span class="plain-syntax">(</span><span class="reserved-syntax">scenes_rcd_data</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">srd</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">during_scene</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">srd</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>

<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">Scenes::new_rcd</span><button class="popup" onclick="togglePopup('usagePopup16')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup16">Usage of <span class="code-font"><span class="function-syntax">Scenes::new_rcd</span></span>:<br/><a href="3-scn.html#SP1">&#167;1</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">id_runtime_context_data</span><span class="plain-syntax"> *</span><span class="identifier-syntax">idrcd</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">CREATE_RCD_FEATURE_DATA</span><span class="plain-syntax">(</span><span class="identifier-syntax">scenes</span><span class="plain-syntax">, </span><span class="identifier-syntax">idrcd</span><span class="plain-syntax">, </span><a href="3-scn.html#SP28" class="function-link"><span class="function-syntax">Scenes::new_rcd_data</span></a><span class="plain-syntax">)</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>

<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">Scenes::set_rcd_spec</span><span class="plain-syntax">(</span><span class="identifier-syntax">id_runtime_context_data</span><span class="plain-syntax"> *</span><span class="identifier-syntax">idrcd</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">to_match</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">scenes_rcd_data</span><span class="plain-syntax"> *</span><span class="identifier-syntax">srcd</span><span class="plain-syntax"> = </span><span class="identifier-syntax">RCD_FEATURE_DATA</span><span class="plain-syntax">(</span><span class="identifier-syntax">scenes</span><span class="plain-syntax">, </span><span class="identifier-syntax">idrcd</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">srcd</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">srcd</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">during_scene</span><span class="plain-syntax"> = </span><span class="identifier-syntax">to_match</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>

<span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="function-syntax">Scenes::get_rcd_spec</span><span class="plain-syntax">(</span><span class="identifier-syntax">id_runtime_context_data</span><span class="plain-syntax"> *</span><span class="identifier-syntax">idrcd</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">scenes_rcd_data</span><span class="plain-syntax"> *</span><span class="identifier-syntax">srcd</span><span class="plain-syntax"> = </span><span class="identifier-syntax">RCD_FEATURE_DATA</span><span class="plain-syntax">(</span><span class="identifier-syntax">scenes</span><span class="plain-syntax">, </span><span class="identifier-syntax">idrcd</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">srcd</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">srcd</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">during_scene</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<ul class="endnotetexts"><li>The structure scenes_rcd_data is private to this section.</li></ul>
<p class="commentary firstcommentary"><a id="SP29" class="paragraph-anchor"></a><b>&#167;29.  </b>The reason we store a whole specification, rather than a scene constant,
here is that we sometimes want rules which happen during "a recurring scene",
or some other description of scenes in general. But the following function
extracts a single specified scene if there is one:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">scene</span><span class="plain-syntax"> *</span><span class="function-syntax">Scenes::rcd_scene</span><span class="plain-syntax">(</span><span class="identifier-syntax">id_runtime_context_data</span><span class="plain-syntax"> *</span><span class="identifier-syntax">idrcd</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">idrcd</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">scenes_rcd_data</span><span class="plain-syntax"> *</span><span class="identifier-syntax">srcd</span><span class="plain-syntax"> = </span><span class="identifier-syntax">RCD_FEATURE_DATA</span><span class="plain-syntax">(</span><span class="identifier-syntax">scenes</span><span class="plain-syntax">, </span><span class="identifier-syntax">idrcd</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">srcd</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Rvalues::is_rvalue</span><span class="plain-syntax">(</span><span class="identifier-syntax">srcd</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">during_scene</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">q</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Rvalues::to_instance</span><span class="plain-syntax">(</span><span class="identifier-syntax">srcd</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">during_scene</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">q</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><a href="3-scn.html#SP13" class="function-link"><span class="function-syntax">Scenes::from_named_constant</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">q</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP30" class="paragraph-anchor"></a><b>&#167;30.  </b>And this is used to make metadata for indexing.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="function-syntax">Scenes::during_wording</span><span class="plain-syntax">(</span><span class="identifier-syntax">id_runtime_context_data</span><span class="plain-syntax"> *</span><span class="identifier-syntax">idrcd</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">idrcd</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">scenes_rcd_data</span><span class="plain-syntax"> *</span><span class="identifier-syntax">srcd</span><span class="plain-syntax"> = </span><span class="identifier-syntax">RCD_FEATURE_DATA</span><span class="plain-syntax">(</span><span class="identifier-syntax">scenes</span><span class="plain-syntax">, </span><span class="identifier-syntax">idrcd</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">srcd</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">srcd</span><span class="plain-syntax">-&gt;</span><span class="element-syntax">during_scene</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">EMPTY_WORDING</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<nav role="progress"><div class="progresscontainer">
    <ul class="progressbar"><li class="progressprev"><a href="3-tr.html">&#10094;</a></li><li class="progresschapter"><a href="P-wtmd.html">P</a></li><li class="progresschapter"><a href="1-im.html">1</a></li><li class="progresschapter"><a href="2-bd.html">2</a></li><li class="progresscurrentchapter">3</li><li class="progresssection"><a href="3-sm.html">sm</a></li><li class="progresssection"><a href="3-enah.html">enah</a></li><li class="progresssection"><a href="3-sr.html">sr</a></li><li class="progresssection"><a href="3-si.html">si</a></li><li class="progresssection"><a href="3-prs.html">prs</a></li><li class="progresssection"><a href="3-tp.html">tp</a></li><li class="progresssection"><a href="3-dvc.html">dvc</a></li><li class="progresssection"><a href="3-bck.html">bck</a></li><li class="progresssection"><a href="3-rgn.html">rgn</a></li><li class="progresssection"><a href="3-tm.html">tm</a></li><li class="progresssection"><a href="3-mcr.html">mcr</a></li><li class="progresssection"><a href="3-tr.html">tr</a></li><li class="progresscurrent">scn</li><li class="progresssection"><a href="3-ts.html">ts</a></li><li class="progresssection"><a href="3-mhr.html">mhr</a></li><li class="progresschapter"><a href="4-ap.html">4</a></li><li class="progresschapter"><a href="5-pp.html">5</a></li><li class="progresschapter"><a href="6-dlg.html">6</a></li><li class="progressnext"><a href="3-ts.html">&#10095;</a></li></ul></div>
</nav><!--End of weave-->

		</main>
	</body>
</html>

