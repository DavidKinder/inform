<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>Map Connection Relations</title>
<link href="../docs-assets/Breadcrumbs.css" rel="stylesheet" rev="stylesheet" type="text/css">
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">

<link href="../docs-assets/Contents.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Progress.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Navigation.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Fonts.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Base.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script>
function togglePopup(material_id) {
  var popup = document.getElementById(material_id);
  popup.classList.toggle("show");
}
</script>

<link href="../docs-assets/Popups.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
		
	</head>
	<body class="commentary-font">
		<nav role="navigation">
		<h1><a href="../index.html">
<img src="../docs-assets/Inform.png" height=72">
</a></h1>
<ul><li><a href="../index.html">home</a></li>
</ul><h2>Compiler</h2><ul>
<li><a href="../structure.html">structure</a></li>
<li><a href="../inbuildn.html">inbuild</a></li>
<li><a href="../inform7n.html">inform7</a></li>
<li><a href="../intern.html">inter</a></li>
<li><a href="../services.html">services</a></li>
<li><a href="../secrets.html">secrets</a></li>
</ul><h2>Other Tools</h2><ul>
<li><a href="../inblorbn.html">inblorb</a></li>
<li><a href="../indocn.html">indoc</a></li>
<li><a href="../inform6.html">inform6</a></li>
<li><a href="../inpolicyn.html">inpolicy</a></li>
</ul><h2>Resources</h2><ul>
<li><a href="../extensions.html">extensions</a></li>
<li><a href="../kits.html">kits</a></li>
</ul><h2>Repository</h2><ul>
<li><a href="https://github.com/ganelson/inform"><img src="../docs-assets/github.png" height=18> github</a></li>
</ul><h2>Related Projects</h2><ul>
<li><a href="../../../inweb/index.html">inweb</a></li>
<li><a href="../../../intest/index.html">intest</a></li>

</ul>
		</nav>
		<main role="main">
		<!-- Weave of 'Map Connection Relations' generated by inweb -->
<div class="breadcrumbs">
    <ul class="crumbs"><li><a href="../index.html">Home</a></li><li><a href="../inform7n.html">Inform7</a></li><li><a href="index.html">if</a></li><li><a href="index.html#3">Chapter 3: Space and Time</a></li><li><b>Map Connection Relations</b></li></ul></div>
<p class="purpose">To define one binary predicate for each map direction, such as "mapped north of".</p>

<ul class="toc"><li><a href="3-mcr.html#SP1">&#167;1. Family</a></li><li><a href="3-mcr.html#SP2">&#167;2. Subsequent creations</a></li><li><a href="3-mcr.html#SP6">&#167;6. Typechecking</a></li><li><a href="3-mcr.html#SP7">&#167;7. Assertion</a></li><li><a href="3-mcr.html#SP8">&#167;8. Indexing</a></li><li><a href="3-mcr.html#SP9">&#167;9. The correspondence with directions</a></li><li><a href="3-mcr.html#SP10">&#167;10. The adjacency relation</a></li></ul><hr class="tocbar">

<p class="commentary firstcommentary"><a id="SP1" class="paragraph-anchor"></a><b>&#167;1. Family.</b>This section creates a family of implicit relations (implemented as binary
predicates) corresponding to the different directions.
</p>

<p class="commentary">For every direction created, a predicate is created for the possibility of
a map connection. For instance, "if Versailles is mapped north of the
Metro" tests the "mapped-north" BP.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">bp_family</span><span class="plain-syntax"> *</span><span class="identifier-syntax">map_connecting_bp_family</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>

<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">MapRelations::start</span><button class="popup" onclick="togglePopup('usagePopup1')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup1">Usage of <span class="code-font"><span class="function-syntax">MapRelations::start</span></span>:<br/>IF Module - <a href="1-im.html#SP2">&#167;2</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">void</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">map_connecting_bp_family</span><span class="plain-syntax"> = </span><span class="identifier-syntax">BinaryPredicateFamilies::new</span><span class="plain-syntax">();</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">METHOD_ADD</span><span class="plain-syntax">(</span><span class="identifier-syntax">map_connecting_bp_family</span><span class="plain-syntax">, </span><span class="identifier-syntax">TYPECHECK_BPF_MTID</span><span class="plain-syntax">, </span><a href="3-mcr.html#SP6" class="function-link"><span class="function-syntax">MapRelations::typecheck</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">METHOD_ADD</span><span class="plain-syntax">(</span><span class="identifier-syntax">map_connecting_bp_family</span><span class="plain-syntax">, </span><span class="identifier-syntax">ASSERT_BPF_MTID</span><span class="plain-syntax">, </span><a href="3-mcr.html#SP7" class="function-link"><span class="function-syntax">MapRelations::assert</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">METHOD_ADD</span><span class="plain-syntax">(</span><span class="identifier-syntax">map_connecting_bp_family</span><span class="plain-syntax">, </span><span class="identifier-syntax">DESCRIBE_FOR_INDEX_BPF_MTID</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><a href="3-mcr.html#SP8" class="function-link"><span class="function-syntax">MapRelations::describe_for_index</span></a><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP2" class="paragraph-anchor"></a><b>&#167;2. Subsequent creations.</b>Every direction created has a relation associated with it: for instance,
"north" has the relation "X is mapped north of Y". Now a direction is a
kind of object, but objects aren't created until after relations used to
parse sentences are needed. In fact, however, directions are "noticed"
at an earlier stage in Inform's run, so another two-step is needed:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">binary_predicate</span><span class="plain-syntax"> *</span><span class="function-syntax">MapRelations::create_sketchy_mapping_direction</span><button class="popup" onclick="togglePopup('usagePopup2')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup2">Usage of <span class="code-font"><span class="function-syntax">MapRelations::create_sketchy_mapping_direction</span></span>:<br/>The Map - <a href="3-tm.html#SP3">&#167;3</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">binary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">bp</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="3-mcr.html#SP2_1" class="named-paragraph-link"><span class="named-paragraph">Create the mapping BP for the new direction</span><span class="named-paragraph-number">2.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">bp</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP3" class="paragraph-anchor"></a><b>&#167;3. </b>When each direction is created, so are corresponding relations and
prepositional uses: for example, "northeast" makes "mapping northeast"
as a relation, and "mapped northeast of" as a prepositional usage.
</p>

<p class="commentary">The rule is actually that production (a) in &lt;mapping-preposition-construction&gt;
is used for all directions except those named in &lt;notable-directions&gt;,
where (b) is used. As a result, we make "mapped inside" and "mapped
outside" instead of "mapped inside of" and "mapped outside of." This
is done to avoid ambiguities with the already-existing meanings of inside
and outside to do with spatial containment.
</p>

<p class="commentary">The use of the word "mapped" may seem itself odd. Why define "to be mapped
east of" rather than "to be east of"? After all, that seems to be what is
used in assertions like:
</p>

<blockquote>
    <p>The Bakery is east of Pudding Lane.</p>
</blockquote>

<p class="commentary">In fact, the assertion parser reads sentences like that by looking out specially
for direction names plus "of" &mdash; so this is parsed without using the mapping
predicate for "east". But it cannot read:
</p>

<blockquote>
    <p>The Flour Cellar is below the Bakery.</p>
</blockquote>

<p class="commentary">as a direction name plus "of", since "below" is not the name of the direction
"down", and anyway there is no "of".
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="function-syntax">&lt;mapping-relation-construction&gt;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">mapping</span><span class="plain-syntax"> ...</span>

<span class="function-syntax">&lt;mapping-preposition-construction&gt;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">mapped</span><span class="plain-syntax"> ... </span><span class="identifier-syntax">of</span><span class="plain-syntax"> |</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">mapped</span><span class="plain-syntax"> ... |</span>
<span class="plain-syntax">    ... </span><span class="identifier-syntax">of</span><span class="plain-syntax"> |</span>
<span class="plain-syntax">    ... </span><span class="identifier-syntax">from</span>
</pre>
<p class="commentary firstcommentary"><a id="SP4" class="paragraph-anchor"></a><b>&#167;4. </b>Two of the directions are special to mapping, because they have to be parsed
slightly differently. (These are the English names; there is no need to translate
this to other languages.)
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="function-syntax">&lt;notable-directions&gt;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">inside</span><span class="plain-syntax"> |</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">outside</span>
</pre>
<p class="commentary firstcommentary"><a id="SP2_1" class="paragraph-anchor"></a><b>&#167;2.1. </b>Directions are detected in sentences having the form "D is a direction." This
is intentionally done very early on.
</p>

<pre class="definitions code-font"><span class="definition-keyword">define</span> <span class="constant-syntax">MAX_MAPPING_RELATION_NAME_LENGTH</span><span class="plain-syntax"> </span><span class="constant-syntax">MAX_WORDS_IN_DIRECTION</span><span class="plain-syntax">*</span><span class="identifier-syntax">MAX_WORD_LENGTH</span><span class="plain-syntax">+10</span>
</pre>
<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Create the mapping BP for the new direction</span><span class="named-paragraph-number">2.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Wordings::length</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">) &gt; </span><span class="constant-syntax">MAX_WORDS_IN_DIRECTION</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">W</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Wordings::truncate</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="constant-syntax">MAX_WORDS_IN_DIRECTION</span><span class="plain-syntax">); </span><span class="comment-syntax"> just truncate for now</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">TEMPORARY_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">relname</span><span class="plain-syntax">) </span><span class="comment-syntax"> for debugging log, e.g., "north-map"</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">WRITE_TO</span><span class="plain-syntax">(</span><span class="identifier-syntax">relname</span><span class="plain-syntax">, </span><span class="string-syntax">"%W-map"</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_THROUGH_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">pos</span><span class="plain-syntax">, </span><span class="identifier-syntax">relname</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Str::get</span><span class="plain-syntax">(</span><span class="identifier-syntax">pos</span><span class="plain-syntax">) == </span><span class="character-syntax">' '</span><span class="plain-syntax">) </span><span class="identifier-syntax">Str::put</span><span class="plain-syntax">(</span><span class="identifier-syntax">pos</span><span class="plain-syntax">, </span><span class="character-syntax">'-'</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">bp_term_details</span><span class="plain-syntax"> </span><span class="identifier-syntax">room_term</span><span class="plain-syntax"> = </span><span class="identifier-syntax">BPTerms::new</span><span class="plain-syntax">(</span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">bp</span><span class="plain-syntax"> = </span><span class="identifier-syntax">BinaryPredicates::make_pair</span><span class="plain-syntax">(</span><span class="identifier-syntax">map_connecting_bp_family</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">room_term</span><span class="plain-syntax">, </span><span class="identifier-syntax">room_term</span><span class="plain-syntax">, </span><span class="identifier-syntax">relname</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">PreformUtilities::merge</span><span class="plain-syntax">(</span><span class="function-syntax">&lt;mapping-relation-construction&gt;</span><span class="plain-syntax">, </span><span class="constant-syntax">0</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">WordAssemblages::from_wording</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">)));</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">mpc_form</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="function-syntax">&lt;notable-directions&gt;</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">)) </span><span class="identifier-syntax">mpc_form</span><span class="plain-syntax"> = </span><span class="constant-syntax">1</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">preposition</span><span class="plain-syntax"> *</span><span class="identifier-syntax">prep1</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Prepositions::make</span><span class="plain-syntax">(</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">PreformUtilities::merge</span><span class="plain-syntax">(</span><span class="function-syntax">&lt;mapping-preposition-construction&gt;</span><span class="plain-syntax">, </span><span class="identifier-syntax">mpc_form</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">WordAssemblages::from_wording</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">)),</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">preposition</span><span class="plain-syntax"> *</span><span class="identifier-syntax">prep2</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Prepositions::make</span><span class="plain-syntax">(</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">PreformUtilities::merge</span><span class="plain-syntax">(</span><span class="function-syntax">&lt;mapping-preposition-construction&gt;</span><span class="plain-syntax">, </span><span class="constant-syntax">2</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">WordAssemblages::from_wording</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">)),</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">preposition</span><span class="plain-syntax"> *</span><span class="identifier-syntax">prep3</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Prepositions::make</span><span class="plain-syntax">(</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">PreformUtilities::merge</span><span class="plain-syntax">(</span><span class="function-syntax">&lt;mapping-preposition-construction&gt;</span><span class="plain-syntax">, </span><span class="constant-syntax">3</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">WordAssemblages::from_wording</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">)),</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">verb_meaning</span><span class="plain-syntax"> </span><span class="identifier-syntax">vm</span><span class="plain-syntax"> = </span><span class="identifier-syntax">VerbMeanings::regular</span><span class="plain-syntax">(</span><span class="identifier-syntax">bp</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Verbs::add_form</span><span class="plain-syntax">(</span><span class="identifier-syntax">copular_verb</span><span class="plain-syntax">, </span><span class="identifier-syntax">prep1</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, </span><span class="identifier-syntax">vm</span><span class="plain-syntax">, </span><span class="identifier-syntax">SVO_FS_BIT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Verbs::add_form</span><span class="plain-syntax">(</span><span class="identifier-syntax">copular_verb</span><span class="plain-syntax">, </span><span class="identifier-syntax">prep2</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, </span><span class="identifier-syntax">vm</span><span class="plain-syntax">, </span><span class="identifier-syntax">SVO_FS_BIT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Verbs::add_form</span><span class="plain-syntax">(</span><span class="identifier-syntax">copular_verb</span><span class="plain-syntax">, </span><span class="identifier-syntax">prep3</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, </span><span class="identifier-syntax">vm</span><span class="plain-syntax">, </span><span class="identifier-syntax">SVO_FS_BIT</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">DISCARD_TEXT</span><span class="plain-syntax">(</span><span class="identifier-syntax">relname</span><span class="plain-syntax">)</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="3-mcr.html#SP2">&#167;2</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP5" class="paragraph-anchor"></a><b>&#167;5. </b>That was one step, and here's the second. At this point we have created the
instance <span class="extract"><span class="extract-syntax">I</span></span> for the direction, and given it the kind "direction". That
makes it possible to complete the details of the BP.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">mmp_call_counter</span><span class="plain-syntax"> = </span><span class="constant-syntax">0</span><span class="plain-syntax">;</span>
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">MapRelations::make_mapped_predicate</span><button class="popup" onclick="togglePopup('usagePopup3')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup3">Usage of <span class="code-font"><span class="function-syntax">MapRelations::make_mapped_predicate</span></span>:<br/>The Map - <a href="3-tm.html#SP18_2">&#167;18.2</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Instances::get_name</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">, </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">Wordings::empty</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">)) || (</span><span class="identifier-syntax">Wordings::length</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">) &gt; </span><span class="constant-syntax">MAX_WORDS_IN_DIRECTION</span><span class="plain-syntax">))</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"bad direction name"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">binary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">bp</span><span class="plain-syntax"> = </span><span class="identifier-syntax">direction_relations_noticed</span><span class="plain-syntax">[</span><span class="identifier-syntax">mmp_call_counter</span><span class="plain-syntax">++];</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">bp</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LOG</span><span class="plain-syntax">(</span><span class="string-syntax">"Improper text: %W\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(),</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_ImproperlyMadeDirection</span><span class="plain-syntax">),</span>
<span class="plain-syntax">            </span><span class="string-syntax">"directions must be created by only the simplest possible sentences"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="string-syntax">"in the form 'North-north-west is a direction' only. Using adjectives, "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"'called', 'which', and so on is not allowed. (In practice this is not "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"too much of a restriction. I won't allow 'Clockwise is a privately-named "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"direction.', but I will allow 'Clockwise is a direction. Clockwise "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"is privately-named.')"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">bp</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">term_details</span><span class="plain-syntax">[0] = </span><span class="identifier-syntax">BPTerms::new</span><span class="plain-syntax">(</span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">bp</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">term_details</span><span class="plain-syntax">[1] = </span><span class="identifier-syntax">BPTerms::new</span><span class="plain-syntax">(</span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">BinaryPredicates::set_index_details</span><span class="plain-syntax">(</span><span class="identifier-syntax">bp</span><span class="plain-syntax">, </span><span class="string-syntax">"room/door"</span><span class="plain-syntax">, </span><span class="string-syntax">"room/door"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">RTMap::set_map_schemas</span><span class="plain-syntax">(</span><span class="identifier-syntax">bp</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">MAP_DATA</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">direction_relation</span><span class="plain-syntax"> = </span><span class="identifier-syntax">bp</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP6" class="paragraph-anchor"></a><b>&#167;6. Typechecking.</b>This won't catch everything, but it will do. Run-time checking will pick up
remaining anomalies.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">MapRelations::typecheck</span><button class="popup" onclick="togglePopup('usagePopup4')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup4">Usage of <span class="code-font"><span class="function-syntax">MapRelations::typecheck</span></span>:<br/><a href="3-mcr.html#SP1">&#167;1</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">bp_family</span><span class="plain-syntax"> *</span><span class="identifier-syntax">self</span><span class="plain-syntax">, </span><span class="identifier-syntax">binary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">bp</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> **</span><span class="identifier-syntax">kinds_of_terms</span><span class="plain-syntax">, </span><span class="identifier-syntax">kind</span><span class="plain-syntax"> **</span><span class="identifier-syntax">kinds_required</span><span class="plain-syntax">, </span><span class="identifier-syntax">tc_problem_kit</span><span class="plain-syntax"> *</span><span class="identifier-syntax">tck</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">t</span><span class="plain-syntax">=0; </span><span class="identifier-syntax">t</span><span class="plain-syntax">&lt;2; </span><span class="identifier-syntax">t</span><span class="plain-syntax">++)</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">Kinds::compatible</span><span class="plain-syntax">(</span><span class="identifier-syntax">kinds_of_terms</span><span class="plain-syntax">[</span><span class="identifier-syntax">t</span><span class="plain-syntax">], </span><span class="identifier-syntax">K_room</span><span class="plain-syntax">) == </span><span class="identifier-syntax">NEVER_MATCH</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">            (</span><span class="identifier-syntax">Kinds::compatible</span><span class="plain-syntax">(</span><span class="identifier-syntax">kinds_of_terms</span><span class="plain-syntax">[</span><span class="identifier-syntax">t</span><span class="plain-syntax">], </span><span class="identifier-syntax">K_door</span><span class="plain-syntax">) == </span><span class="identifier-syntax">NEVER_MATCH</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">TypecheckPropositions::issue_bp_typecheck_error</span><span class="plain-syntax">(</span><span class="identifier-syntax">bp</span><span class="plain-syntax">, </span><span class="identifier-syntax">kinds_of_terms</span><span class="plain-syntax">[0],</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">kinds_of_terms</span><span class="plain-syntax">[1], </span><span class="identifier-syntax">tck</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NEVER_MATCH</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">ALWAYS_MATCH</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP7" class="paragraph-anchor"></a><b>&#167;7. Assertion.</b>Note that the following will infer <span class="extract"><span class="extract-syntax">IS_ROOM_INF</span></span> for any source of a map
connection &mdash; which will include doors. That doesn't matter, because the
Spatial feature uses these inferences only for objects whose kind is not
explicitly given in the source text; and doors must always be specified as
such.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="function-syntax">MapRelations::assert</span><button class="popup" onclick="togglePopup('usagePopup5')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup5">Usage of <span class="code-font"><span class="function-syntax">MapRelations::assert</span></span>:<br/><a href="3-mcr.html#SP1">&#167;1</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">bp_family</span><span class="plain-syntax"> *</span><span class="identifier-syntax">self</span><span class="plain-syntax">, </span><span class="identifier-syntax">binary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">bp</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">infs0</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec0</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">infs1</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec1</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">o_dir</span><span class="plain-syntax"> = </span><a href="3-mcr.html#SP9" class="function-link"><span class="function-syntax">MapRelations::get_mapping_direction</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">bp</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">infs_to</span><span class="plain-syntax"> = </span><span class="identifier-syntax">infs0</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">inference_subject</span><span class="plain-syntax"> *</span><span class="identifier-syntax">infs_from</span><span class="plain-syntax"> = </span><span class="identifier-syntax">infs1</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><a href="3-si.html#SP3" class="function-link"><span class="function-syntax">SpatialInferences::infer_is_room</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">infs_from</span><span class="plain-syntax">, </span><span class="identifier-syntax">prevailing_mood</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">prevailing_mood</span><span class="plain-syntax"> &gt;= </span><span class="constant-syntax">0</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">infs_to</span><span class="plain-syntax">))</span>
<span class="plain-syntax">        </span><a href="3-si.html#SP3" class="function-link"><span class="function-syntax">SpatialInferences::infer_is_room</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">infs_to</span><span class="plain-syntax">, </span><span class="identifier-syntax">LIKELY_CE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><a href="3-tm.html#SP5" class="function-link"><span class="function-syntax">Map::infer_direction</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">infs_from</span><span class="plain-syntax">, </span><span class="identifier-syntax">infs_to</span><span class="plain-syntax">, </span><span class="identifier-syntax">o_dir</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP8" class="paragraph-anchor"></a><b>&#167;8. Indexing.</b></p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">MapRelations::describe_for_index</span><button class="popup" onclick="togglePopup('usagePopup6')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup6">Usage of <span class="code-font"><span class="function-syntax">MapRelations::describe_for_index</span></span>:<br/><a href="3-mcr.html#SP1">&#167;1</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">bp_family</span><span class="plain-syntax"> *</span><span class="identifier-syntax">self</span><span class="plain-syntax">, </span><span class="identifier-syntax">OUTPUT_STREAM</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">binary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">bp</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">WRITE</span><span class="plain-syntax">(</span><span class="string-syntax">"map"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP9" class="paragraph-anchor"></a><b>&#167;9. The correspondence with directions.</b>Speed really does not matter here.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">binary_predicate</span><span class="plain-syntax"> *</span><span class="function-syntax">MapRelations::get_mapping_relation</span><button class="popup" onclick="togglePopup('usagePopup7')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup7">Usage of <span class="code-font"><span class="function-syntax">MapRelations::get_mapping_relation</span></span>:<br/>The Map - <a href="3-tm.html#SP32">&#167;32</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">dir</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">dir</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">MAP_DATA</span><span class="plain-syntax">(</span><span class="identifier-syntax">dir</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">direction_relation</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>

<span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="function-syntax">MapRelations::get_mapping_direction</span><button class="popup" onclick="togglePopup('usagePopup8')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup8">Usage of <span class="code-font"><span class="function-syntax">MapRelations::get_mapping_direction</span></span>:<br/><a href="3-mcr.html#SP7">&#167;7</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">binary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">bp</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">bp</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOOP_OVER_INSTANCES</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">, </span><span class="identifier-syntax">K_object</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">MAP_DATA</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">)-&gt;</span><span class="element-syntax">direction_relation</span><span class="plain-syntax"> == </span><span class="identifier-syntax">bp</span><span class="plain-syntax">)</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">I</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>

<span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="function-syntax">MapRelations::get_mapping_relationship</span><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">binary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">bp</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::get_relationship</span><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">bp</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">FEATURE_ACTIVE</span><span class="plain-syntax">(</span><span class="identifier-syntax">map</span><span class="plain-syntax">))) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">dir</span><span class="plain-syntax"> = </span><a href="3-mcr.html#SP9" class="function-link"><span class="function-syntax">MapRelations::get_mapping_direction</span></a><span class="plain-syntax">(</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">BinaryPredicates::get_reversal</span><span class="plain-syntax">(</span><span class="identifier-syntax">bp</span><span class="plain-syntax">));</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">dir</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="identifier-syntax">dir</span><span class="plain-syntax"> = </span><a href="3-mcr.html#SP9" class="function-link"><span class="function-syntax">MapRelations::get_mapping_direction</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">bp</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">dir</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP10" class="paragraph-anchor"></a><b>&#167;10. The adjacency relation.</b>There is also one general relation built in, though it belongs to the spatial family:
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">MapRelations::create_relations</span><button class="popup" onclick="togglePopup('usagePopup9')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup9">Usage of <span class="code-font"><span class="function-syntax">MapRelations::create_relations</span></span>:<br/>Spatial Relations - <a href="3-sr.html#SP2">&#167;2</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">void</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">BinaryPredicates::make_pair</span><span class="plain-syntax">(</span><span class="identifier-syntax">spatial_bp_family</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">BPTerms::new</span><span class="plain-syntax">(</span><span class="identifier-syntax">infs_room</span><span class="plain-syntax">),</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">BPTerms::new</span><span class="plain-syntax">(</span><span class="identifier-syntax">infs_room</span><span class="plain-syntax">),</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">I</span><span class="string-syntax">"adjacent-to"</span><span class="plain-syntax">, </span><span class="identifier-syntax">I</span><span class="string-syntax">"adjacent-from"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, </span><span class="identifier-syntax">Calculus::Schemas::new</span><span class="plain-syntax">(</span><span class="string-syntax">"TestAdjacency(*1,*2)"</span><span class="plain-syntax">),</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">PreformUtilities::wording</span><span class="plain-syntax">(</span><span class="function-syntax">&lt;relation-names&gt;</span><span class="plain-syntax">, </span><span class="identifier-syntax">ADJACENCY_RELATION_NAME</span><span class="plain-syntax">));</span>
<span class="plain-syntax">}</span>
</pre>
<nav role="progress"><div class="progresscontainer">
    <ul class="progressbar"><li class="progressprev"><a href="3-tm.html">&#10094;</a></li><li class="progresschapter"><a href="P-wtmd.html">P</a></li><li class="progresschapter"><a href="1-im.html">1</a></li><li class="progresschapter"><a href="2-bd.html">2</a></li><li class="progresscurrentchapter">3</li><li class="progresssection"><a href="3-sm.html">sm</a></li><li class="progresssection"><a href="3-enah.html">enah</a></li><li class="progresssection"><a href="3-sr.html">sr</a></li><li class="progresssection"><a href="3-si.html">si</a></li><li class="progresssection"><a href="3-prs.html">prs</a></li><li class="progresssection"><a href="3-tp.html">tp</a></li><li class="progresssection"><a href="3-dvc.html">dvc</a></li><li class="progresssection"><a href="3-bck.html">bck</a></li><li class="progresssection"><a href="3-rgn.html">rgn</a></li><li class="progresssection"><a href="3-tm.html">tm</a></li><li class="progresscurrent">mcr</li><li class="progresssection"><a href="3-tr.html">tr</a></li><li class="progresssection"><a href="3-scn.html">scn</a></li><li class="progresssection"><a href="3-ts.html">ts</a></li><li class="progresssection"><a href="3-mhr.html">mhr</a></li><li class="progresschapter"><a href="4-ap.html">4</a></li><li class="progresschapter"><a href="5-pp.html">5</a></li><li class="progresschapter"><a href="6-dlg.html">6</a></li><li class="progressnext"><a href="3-tr.html">&#10095;</a></li></ul></div>
</nav><!-- End of weave -->

		</main>
	</body>
</html>

