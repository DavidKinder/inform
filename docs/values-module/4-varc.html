<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
	<head>
		<title>Verbal and Relative Clauses</title>
<link href="../docs-assets/Breadcrumbs.css" rel="stylesheet" rev="stylesheet" type="text/css">
		<meta name="viewport" content="width=device-width initial-scale=1">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="Content-Language" content="en-gb">

<link href="../docs-assets/Contents.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Progress.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Navigation.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Fonts.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Base.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script src="http://code.jquery.com/jquery-1.12.4.min.js"
	integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>

<script src="../docs-assets/Bigfoot.js"></script>
<link href="../docs-assets/Bigfoot.css" rel="stylesheet" rev="stylesheet" type="text/css">
<script>
function togglePopup(material_id) {
  var popup = document.getElementById(material_id);
  popup.classList.toggle("show");
}
</script>

<link href="../docs-assets/Popups.css" rel="stylesheet" rev="stylesheet" type="text/css">
<link href="../docs-assets/Colours.css" rel="stylesheet" rev="stylesheet" type="text/css">
		
	</head>
	<body class="commentary-font">
		<nav role="navigation">
		<h1><a href="../index.html">
<img src="../docs-assets/Inform.png" height=72">
</a></h1>
<ul><li><a href="../index.html">home</a></li>
</ul><h2>Compiler</h2><ul>
<li><a href="../structure.html">structure</a></li>
<li><a href="../inbuildn.html">inbuild</a></li>
<li><a href="../inform7n.html">inform7</a></li>
<li><a href="../intern.html">inter</a></li>
<li><a href="../services.html">services</a></li>
<li><a href="../secrets.html">secrets</a></li>
</ul><h2>Other Tools</h2><ul>
<li><a href="../inblorbn.html">inblorb</a></li>
<li><a href="../indocn.html">indoc</a></li>
<li><a href="../inform6.html">inform6</a></li>
<li><a href="../inpolicyn.html">inpolicy</a></li>
</ul><h2>Resources</h2><ul>
<li><a href="../extensions.html">extensions</a></li>
<li><a href="../kits.html">kits</a></li>
</ul><h2>Repository</h2><ul>
<li><a href="https://github.com/ganelson/inform"><img src="../docs-assets/github.png" height=18> github</a></li>
</ul><h2>Related Projects</h2><ul>
<li><a href="../../../inweb/index.html">inweb</a></li>
<li><a href="../../../intest/index.html">intest</a></li>

</ul>
		</nav>
		<main role="main">
		<!-- Weave of 'Verbal and Relative Clauses' generated by inweb -->
<div class="breadcrumbs">
    <ul class="crumbs"><li><a href="../index.html">Home</a></li><li><a href="../inform7n.html">Inform7</a></li><li><a href="index.html">values</a></li><li><a href="index.html#4">Chapter 4: The S-Parser</a></li><li><b>Verbal and Relative Clauses</b></li></ul></div>
<p class="purpose">To break down an excerpt into NP and VP-like clauses, perhaps with a primary verb (to make a sentence), perhaps only a relative clause (to make a more complex NP).</p>

<ul class="toc"><li><a href="4-varc.html#SP1">&#167;1. SVO phrases</a></li><li><a href="4-varc.html#SP6">&#167;6. Tidying up a sentence subtree</a></li><li><a href="4-varc.html#SP7">&#167;7. Values as noun phrases</a></li><li><a href="4-varc.html#SP11">&#167;11. Junction</a></li><li><a href="4-varc.html#SP13">&#167;13. Internal test for sentence parsing</a></li></ul><hr class="tocbar">

<p class="commentary firstcommentary"><a id="SP1" class="paragraph-anchor"></a><b>&#167;1. SVO phrases.</b>English is an SVO language, where the main parts of the sentence occur in the
order subject, verb, object. The following grammar parses that crucial division,
and note that it can be used either to form a complete sentence, where there
is an active verb &mdash;
</p>

<blockquote>
    <p>now the silver bars are in the Hall of Mists;</p>
</blockquote>

<p class="commentary">or alternatively to make a more elaborate noun phrase, using a relative clause,
where there is no active verb:
</p>

<blockquote>
    <p>a woman who carries the silver bars;</p>
</blockquote>

<p class="commentary">We sometimes also have to deal with English's use of "there" as a meaningless
placeholder to stand for a missing noun phrase:
</p>

<blockquote>
    <p>there is an open door</p>
</blockquote>

<pre class="displayed-code all-displayed-code code-font">
<span class="function-syntax">&lt;s-sentence&gt;</span>
<span class="plain-syntax">    </span><span class="function-syntax">&lt;np-existential&gt;</span><span class="plain-syntax"> </span><span class="function-syntax">&lt;s-existential-verb-tail&gt;</span><span class="plain-syntax"> |</span>
<span class="plain-syntax">    </span><span class="function-syntax">&lt;s-noun-phrase&gt;</span><span class="plain-syntax"> </span><span class="function-syntax">&lt;s-general-verb-tail&gt;</span>

<span class="function-syntax">&lt;s-existential-verb-tail&gt;</span>
<span class="plain-syntax">    </span><span class="function-syntax">&lt;copular-verb&gt;</span><span class="plain-syntax"> </span><span class="function-syntax">&lt;s-noun-phrase-nounless&gt;</span>
</pre>
<p class="commentary firstcommentary"><a id="SP1_1" class="paragraph-anchor"></a><b>&#167;1.1. </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Make SV</span><span class="named-paragraph-number">1.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><a href="4-varc.html#SP6" class="function-link"><span class="function-syntax">SPVerb::correct_for_adjectives</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">RP</span><span class="plain-syntax">[1], </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[2]);</span>
<span class="plain-syntax">    ==&gt; { -, </span><a href="4-varc.html#SP11" class="function-link"><span class="function-syntax">SPVerb::to_specification</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[1], </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[2]) }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-varc.html#SP1">&#167;1</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP1_2" class="paragraph-anchor"></a><b>&#167;1.2. </b>An ugly trick, invisible from the grammar itself, is that we forbid the
object to be a value. This removes cases like "if there is 21", but in fact
we do it to avoid problem messages whenever a table column exists with the
name "there". (Because of the unfortunately worded phrase "there is T"
for a table reference; the phrase should never have been called something
so ambiguous &mdash; a bad decision in about 2003.)
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Make SV provided object is descriptive</span><span class="named-paragraph-number">1.2</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">op</span><span class="plain-syntax"> = </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[2];</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">test</span><span class="plain-syntax"> = </span><span class="identifier-syntax">op</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Node::is</span><span class="plain-syntax">(</span><span class="identifier-syntax">test</span><span class="plain-syntax">, </span><span class="identifier-syntax">AMBIGUITY_NT</span><span class="plain-syntax">)) </span><span class="identifier-syntax">test</span><span class="plain-syntax"> = </span><span class="identifier-syntax">test</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><a href="2-spc.html#SP3" class="function-link"><span class="function-syntax">Specifications::is_description_like</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">test</span><span class="plain-syntax">) == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) { ==&gt; { </span><span class="identifier-syntax">fail</span><span class="plain-syntax"> } }</span>
<span class="plain-syntax">    ==&gt; { -, </span><a href="4-varc.html#SP11" class="function-link"><span class="function-syntax">SPVerb::to_specification</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, </span><span class="identifier-syntax">op</span><span class="plain-syntax">) }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-varc.html#SP1">&#167;1</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP2" class="paragraph-anchor"></a><b>&#167;2. </b>More generally, the tail syntax splits according to the verb in question. The
copular verb "to be" has special syntactic rules for its object phrase (for
Inform, at least: linguists would probably analyse this slightly differently).
We've just seen one special point: "to be" can take the placeholder
"there", which no other verb can.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> The verb "to be" is "copular" because it
acts to combine its subject and object: "X is 5", "Y is blue", and so on, refer
to just one thing but make a statement about its nature or identity.
Other verbs &mdash; "to carry", say &mdash; normally refer to two different things, at
least in their most general forms: "X carries the briefcase".
</p>

<p class="commentary">The universal verb "to relate" needs a special syntax in order to handle its
extra object: see below.
</p>

<ul class="footnotetexts"><li class="footnote" id="fn:1"><p class="inwebfootnote"><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> English does allow this, for archaic or dramatic purposes: "There lurks
<a href="#fnref:1" title="return to text"> &#x21A9;</a></p></li><li class="footnote" id="fn:1"><p class="inwebfootnote">a mysterious invisible force." Inform doesn't, and it also doesn't read the
<a href="#fnref:1" title="return to text"> &#x21A9;</a></p></li><li class="footnote" id="fn:1"><p class="inwebfootnote">mathematical usage "there exists", alas.
<a href="#fnref:1" title="return to text"> &#x21A9;</a></p></li></ul>
<pre class="displayed-code all-displayed-code code-font">
<span class="function-syntax">&lt;s-general-verb-tail&gt;</span>
<span class="plain-syntax">    </span><span class="function-syntax">&lt;universal-verb&gt;</span><span class="plain-syntax"> </span><span class="function-syntax">&lt;s-universal-term&gt;</span><span class="plain-syntax"> |</span>
<span class="plain-syntax">    </span><span class="function-syntax">&lt;nonimperative-verb&gt;</span><span class="plain-syntax"> </span><span class="function-syntax">&lt;permitted-preposition&gt;</span><span class="plain-syntax"> </span><span class="function-syntax">&lt;s-noun-phrase&gt;</span><span class="plain-syntax"> |</span>
<span class="plain-syntax">    </span><span class="function-syntax">&lt;nonimperative-verb&gt;</span><span class="plain-syntax"> </span><span class="function-syntax">&lt;s-noun-phrase&gt;</span>
</pre>
<p class="commentary firstcommentary"><a id="SP3" class="paragraph-anchor"></a><b>&#167;3. </b>The verb marker is a temporary node used just to store the verb or preposition
usage; it's attached to the tree only briefly before sentence conversion
removes it again.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="function-syntax">SPVerb::marker</span><button class="popup" onclick="togglePopup('usagePopup1')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup1">Usage of <span class="code-font"><span class="function-syntax">SPVerb::marker</span></span>:<br/><a href="4-varc.html#SP1">&#167;1</a>, <a href="4-varc.html#SP2">&#167;2</a>, <a href="4-varc.html#SP5">&#167;5</a>, <a href="4-varc.html#SP11_1">&#167;11.1</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">verb_usage</span><span class="plain-syntax"> *</span><span class="identifier-syntax">vu</span><span class="plain-syntax">, </span><span class="identifier-syntax">preposition</span><span class="plain-syntax"> *</span><span class="identifier-syntax">prep</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">np</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">VP_part</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::new</span><span class="plain-syntax">(</span><span class="identifier-syntax">UNKNOWN_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_verb</span><span class="plain-syntax">(</span><span class="identifier-syntax">VP_part</span><span class="plain-syntax">, </span><span class="identifier-syntax">vu</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_preposition</span><span class="plain-syntax">(</span><span class="identifier-syntax">VP_part</span><span class="plain-syntax">, </span><span class="identifier-syntax">prep</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">VP_part</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax"> = </span><span class="identifier-syntax">np</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">VP_part</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP4" class="paragraph-anchor"></a><b>&#167;4. </b>The following catches the "Y to Z" right-hand term of the universal relation,
</p>

<blockquote>
    <p>X relates Y to Z</p>
</blockquote>

<p class="commentary">where Y and Z must somehow be folded into a single noun phrase. Conceptually it
would be neatest to represent this as a combination kind, but that might lead
us to require the presence of the heap, since combinations are stored on the
heap; and that would effectively make "relates" of limited use on Z-machine
works.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="function-syntax">&lt;s-universal-term&gt;</span>
<span class="plain-syntax">    </span><span class="function-syntax">&lt;s-noun-phrase&gt;</span><span class="plain-syntax"> </span><span class="identifier-syntax">to</span><span class="plain-syntax"> </span><span class="function-syntax">&lt;s-noun-phrase&gt;</span>
</pre>
<p class="commentary firstcommentary"><a id="SP5" class="paragraph-anchor"></a><b>&#167;5. </b>The following parses a noun phrase with a relative clause, which is
syntactically very similar to the case of a sentence. Sometimes the verb is
explicit, as here:
</p>

<blockquote>
    <p>a woman who does not carry an animal</p>
</blockquote>

<p class="commentary">in which case "who", acting as a marker of the relative clause, is the
only way this differs from a sentence; but sometimes it is implicit:
</p>

<blockquote>
    <p>a woman not in the Hall of Mists</p>
</blockquote>

<p class="commentary">In this case the verb is implicitly the copular verb "to be" and our
grammar has to differ from the sentence grammar above.
</p>

<p class="commentary">Some prepositions imply the player as object: "carried", in the sense of
"to be carried", for instance &mdash; "The briefcase is carried". We fill the
relevant noun subtree with a representation of the player-object for those.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="function-syntax">&lt;s-np-with-relative-clause&gt;</span>
<span class="plain-syntax">    </span><span class="function-syntax">&lt;s-noun-phrase-nounless&gt;</span><span class="plain-syntax"> </span><span class="function-syntax">&lt;s-implied-relative-verb-tail&gt;</span><span class="plain-syntax"> |</span>
<span class="plain-syntax">    </span><span class="function-syntax">&lt;s-noun-phrase&gt;</span><span class="plain-syntax"> </span><span class="function-syntax">&lt;s-relative-verb-tail&gt;</span>

<span class="function-syntax">&lt;s-implied-relative-verb-tail&gt;</span>
<span class="plain-syntax">    </span><span class="function-syntax">&lt;copular-preposition&gt;</span><span class="plain-syntax"> </span><span class="function-syntax">&lt;s-noun-phrase-nounless&gt;</span><span class="plain-syntax"> |</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">not</span><span class="plain-syntax"> </span><span class="function-syntax">&lt;copular-preposition&gt;</span><span class="plain-syntax"> </span><span class="function-syntax">&lt;s-noun-phrase-nounless&gt;</span>

<span class="function-syntax">&lt;s-relative-verb-tail&gt;</span>
<span class="plain-syntax">    </span><span class="function-syntax">&lt;rc-marker&gt;</span><span class="plain-syntax"> </span><span class="function-syntax">&lt;universal-verb&gt;</span><span class="plain-syntax"> </span><span class="function-syntax">&lt;s-universal-term&gt;</span><span class="plain-syntax"> |</span>
<span class="plain-syntax">    </span><span class="function-syntax">&lt;rc-marker&gt;</span><span class="plain-syntax"> </span><span class="function-syntax">&lt;nonimperative-verb&gt;</span><span class="plain-syntax"> </span><span class="function-syntax">&lt;permitted-preposition&gt;</span><span class="plain-syntax"> </span><span class="function-syntax">&lt;s-noun-phrase&gt;</span><span class="plain-syntax"> |</span>
<span class="plain-syntax">    </span><span class="function-syntax">&lt;rc-marker&gt;</span><span class="plain-syntax"> </span><span class="function-syntax">&lt;nonimperative-verb&gt;</span><span class="plain-syntax"> </span><span class="function-syntax">&lt;s-noun-phrase&gt;</span>
</pre>
<p class="commentary firstcommentary"><a id="SP5_1" class="paragraph-anchor"></a><b>&#167;5.1. </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Make SN</span><span class="named-paragraph-number">5.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">MATCHING</span><span class="plain-syntax">, </span><span class="string-syntax">"So uncorrectedly RP[1] = $T\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[1]);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">LOGIF</span><span class="plain-syntax">(</span><span class="identifier-syntax">MATCHING</span><span class="plain-syntax">, </span><span class="string-syntax">"and uncorrectedly RP[2] = $T\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[2]);</span>
<span class="plain-syntax">    </span><a href="4-varc.html#SP6" class="function-link"><span class="function-syntax">SPVerb::correct_for_adjectives</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">RP</span><span class="plain-syntax">[1], </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[2]);</span>
<span class="plain-syntax">    ==&gt; { -, </span><a href="4-varc.html#SP11" class="function-link"><span class="function-syntax">SPVerb::to_specification</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[1], </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[2]) };</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-varc.html#SP5">&#167;5</a> (twice).</li></ul>
<p class="commentary firstcommentary"><a id="SP6" class="paragraph-anchor"></a><b>&#167;6. Tidying up a sentence subtree.</b>This checks, in a paranoid sort of way, that a subtree is properly formed,
and also makes one useful correction when it sees a wrong guess as to whether
an adjective is meant as a noun.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">SPVerb::correct_for_adjectives</span><button class="popup" onclick="togglePopup('usagePopup2')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup2">Usage of <span class="code-font"><span class="function-syntax">SPVerb::correct_for_adjectives</span></span>:<br/><a href="4-varc.html#SP1_1">&#167;1.1</a>, <a href="4-varc.html#SP5_1">&#167;5.1</a>, <a href="4-varc.html#SP11_1">&#167;11.1</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">A</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">B</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">subject_phrase_subtree</span><span class="plain-syntax">, *</span><span class="identifier-syntax">object_phrase_subtree</span><span class="plain-syntax">, *</span><span class="identifier-syntax">verb_phrase_subtree</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">A</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"SV childless"</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">subject_phrase_subtree</span><span class="plain-syntax"> = </span><span class="identifier-syntax">A</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">verb_phrase_subtree</span><span class="plain-syntax"> = </span><span class="identifier-syntax">B</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">verb_phrase_subtree</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">internal_error</span><span class="plain-syntax">(</span><span class="string-syntax">"SV childless"</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">object_phrase_subtree</span><span class="plain-syntax"> = </span><span class="identifier-syntax">verb_phrase_subtree</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="4-varc.html#SP6_1" class="named-paragraph-link"><span class="named-paragraph">Modify the object from a noun to an adjective if the subject is also a noun</span><span class="named-paragraph-number">6.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP6_1" class="paragraph-anchor"></a><b>&#167;6.1. </b>The following is used to correct the SV-subtree for something like "painting
is orange" so that "orange" will be used not as a noun but as an adjective.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Modify the object from a noun to an adjective if the subject is also a noun</span><span class="named-paragraph-number">6.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><a href="2-rvl.html#SP5" class="function-link"><span class="function-syntax">Rvalues::to_instance</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">object_phrase_subtree</span><span class="plain-syntax">)) &amp;&amp;</span>
<span class="plain-syntax">        (</span><span class="identifier-syntax">subject_phrase_subtree</span><span class="plain-syntax">) &amp;&amp;</span>
<span class="plain-syntax">        (</span><a href="2-spc.html#SP3" class="function-link"><span class="function-syntax">Specifications::is_description_like</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">subject_phrase_subtree</span><span class="plain-syntax">))) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">adjq</span><span class="plain-syntax"> = </span><span class="identifier-syntax">object_phrase_subtree</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">instance</span><span class="plain-syntax"> *</span><span class="identifier-syntax">I</span><span class="plain-syntax"> = </span><a href="2-rvl.html#SP5" class="function-link"><span class="function-syntax">Rvalues::to_instance</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">adjq</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Instances::as_adjective</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">unary_predicate</span><span class="plain-syntax"> *</span><span class="identifier-syntax">ale</span><span class="plain-syntax"> = </span><span class="identifier-syntax">AdjectivalPredicates::new_up</span><span class="plain-syntax">(</span><span class="identifier-syntax">Instances::as_adjective</span><span class="plain-syntax">(</span><span class="identifier-syntax">I</span><span class="plain-syntax">), </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec</span><span class="plain-syntax"> = </span><a href="2-dsc.html#SP1" class="function-link"><span class="function-syntax">Descriptions::from_proposition</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, </span><span class="identifier-syntax">Node::get_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">adjq</span><span class="plain-syntax">));</span>
<span class="plain-syntax">            </span><a href="2-dsc.html#SP8" class="function-link"><span class="function-syntax">Descriptions::add_to_adjective_list</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">ale</span><span class="plain-syntax">, </span><span class="identifier-syntax">spec</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">verb_phrase_subtree</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax"> = </span><span class="identifier-syntax">spec</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-varc.html#SP6">&#167;6</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP7" class="paragraph-anchor"></a><b>&#167;7. Values as noun phrases.</b>It is very nearly true that the subject and object noun phrases are parsed
by &lt;s-value&gt;, which was given in <a href="4-teav.html" class="internal">Type Expressions and Values</a>. But there
is a technicality: for reasons to do with ambiguities, &lt;s-value&gt; needs to
be able to try descriptions which involve only physical objects at one stage,
and then later to try other descriptions.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">force_all_SP_noun_phrases_to_be_physical</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
</pre>
<p class="commentary firstcommentary"><a id="SP8" class="paragraph-anchor"></a><b>&#167;8. </b>Note that &lt;s-purely-physical-description&gt; calls &lt;s-description&gt; which in
turn may, if there's a relative clause, call &lt;s-np-with-relative-clause&gt; and thus
&lt;s-noun-phrase&gt;. Rather than passing endless copies of a flag down the call
stack, we simply give &lt;s-noun-phrase&gt; a global mode of operation.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="function-syntax">&lt;s-purely-physical-description&gt;</span><span class="plain-syntax"> </span><span class="identifier-syntax">internal</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">s</span><span class="plain-syntax"> = </span><span class="identifier-syntax">force_all_SP_noun_phrases_to_be_physical</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">force_all_SP_noun_phrases_to_be_physical</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="function-syntax">&lt;s-description&gt;</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">)) </span><span class="identifier-syntax">p</span><span class="plain-syntax"> = </span><span class="function-syntax">&lt;&lt;rp&gt;&gt;</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">force_all_SP_noun_phrases_to_be_physical</span><span class="plain-syntax"> = </span><span class="identifier-syntax">s</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">p</span><span class="plain-syntax">) { ==&gt; { -, </span><span class="identifier-syntax">p</span><span class="plain-syntax"> }; </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">; }</span>
<span class="plain-syntax">    ==&gt; { </span><span class="identifier-syntax">fail</span><span class="plain-syntax"> </span><span class="identifier-syntax">nonterminal</span><span class="plain-syntax"> };</span>
<span class="plain-syntax">}</span>

<span class="function-syntax">&lt;if-forced-physical&gt;</span><span class="plain-syntax"> </span><span class="identifier-syntax">internal</span><span class="plain-syntax"> </span><span class="constant-syntax">0</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">force_all_SP_noun_phrases_to_be_physical</span><span class="plain-syntax">) </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    ==&gt; { </span><span class="identifier-syntax">fail</span><span class="plain-syntax"> </span><span class="identifier-syntax">nonterminal</span><span class="plain-syntax"> };</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP9" class="paragraph-anchor"></a><b>&#167;9. </b>The upshot of this is that &lt;s-noun-phrase&gt; is only ever called in "purely
physical mode" when it will later be called outside that mode in any event,
and that therefore the set of excerpts matched by &lt;s-noun-phrase&gt; genuinely
is the same as that matched by &lt;s-value&gt;.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="function-syntax">&lt;s-noun-phrase&gt;</span>
<span class="plain-syntax">    </span><span class="function-syntax">&lt;if-forced-physical&gt;</span><span class="plain-syntax"> </span><span class="function-syntax">&lt;s-variable-as-value&gt;</span><span class="plain-syntax"> |</span>
<span class="plain-syntax">    </span><span class="function-syntax">&lt;if-forced-physical&gt;</span><span class="plain-syntax"> </span><span class="function-syntax">&lt;s-description&gt;</span><span class="plain-syntax"> |</span>
<span class="plain-syntax">    ^</span><span class="function-syntax">&lt;if-forced-physical&gt;</span><span class="plain-syntax"> </span><span class="function-syntax">&lt;s-value-uncached&gt;</span><span class="plain-syntax"> |</span>

<span class="function-syntax">&lt;s-noun-phrase-nounless&gt;</span>
<span class="plain-syntax">    </span><span class="function-syntax">&lt;if-forced-physical&gt;</span><span class="plain-syntax"> </span><span class="function-syntax">&lt;s-variable-as-value&gt;</span><span class="plain-syntax"> |</span>
<span class="plain-syntax">    </span><span class="function-syntax">&lt;if-forced-physical&gt;</span><span class="plain-syntax"> </span><span class="function-syntax">&lt;s-desc-nounless&gt;</span><span class="plain-syntax"> |</span>
<span class="plain-syntax">    ^</span><span class="function-syntax">&lt;if-forced-physical&gt;</span><span class="plain-syntax"> </span><span class="function-syntax">&lt;s-value-uncached&gt;</span><span class="plain-syntax"> |</span>
</pre>
<p class="commentary firstcommentary"><a id="SP10" class="paragraph-anchor"></a><b>&#167;10. </b>Finally, the following is needed for conditions ("if fixed in place
scenery, ...") where the object referred to is understood from context.
</p>

<p class="commentary">The reason a literal number is explicitly not allowed to be a condition is
that if something is created called (say) "Room 62" then "62" might be read
by &lt;s-description&gt; as an abbreviated reference to that room. (This doesn't
happen with non-descriptive NPs because then literal values are tried earlier,
pre-empting descriptions.)
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="function-syntax">&lt;s-descriptive-np&gt;</span>
<span class="plain-syntax">    ( </span><span class="function-syntax">&lt;s-descriptive-np&gt;</span><span class="plain-syntax"> ) |</span>
<span class="plain-syntax">    </span><span class="function-syntax">&lt;cardinal-number&gt;</span><span class="plain-syntax"> |</span>
<span class="plain-syntax">    </span><span class="function-syntax">&lt;s-description&gt;</span><span class="plain-syntax"> |</span>
<span class="plain-syntax">    </span><span class="function-syntax">&lt;s-adjective-list-as-desc&gt;</span>
</pre>
<p class="commentary firstcommentary"><a id="SP10_1" class="paragraph-anchor"></a><b>&#167;10.1. </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Construct a descriptive SN subtree</span><span class="named-paragraph-number">10.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">sn</span><span class="plain-syntax"> = </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[1];</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Annotations::read_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">sn</span><span class="plain-syntax">, </span><span class="identifier-syntax">converted_SN_ANNOT</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        ==&gt; { -, </span><span class="identifier-syntax">sn</span><span class="plain-syntax"> };</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">        ==&gt; { -, </span><a href="4-varc.html#SP11" class="function-link"><span class="function-syntax">SPVerb::to_specification</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="identifier-syntax">RP</span><span class="plain-syntax">[1], </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) };</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">pn</span><span class="plain-syntax"> = *</span><span class="identifier-syntax">XP</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">pn</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-varc.html#SP10">&#167;10</a> (twice).</li></ul>
<p class="commentary firstcommentary"><a id="SP11" class="paragraph-anchor"></a><b>&#167;11. Junction.</b>At this point we need to join two subtrees, called <span class="extract"><span class="extract-syntax">A</span></span> and <span class="extract"><span class="extract-syntax">B</span></span>. <span class="extract"><span class="extract-syntax">A</span></span> is the
subject of the sentence phrase, <span class="extract"><span class="extract-syntax">B</span></span> contains the verb marker and also the
object.
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">PM_DescLocalPast_location</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>

<span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="function-syntax">SPVerb::to_specification</span><button class="popup" onclick="togglePopup('usagePopup3')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup3">Usage of <span class="code-font"><span class="function-syntax">SPVerb::to_specification</span></span>:<br/><a href="4-varc.html#SP1_1">&#167;1.1</a>, <a href="4-varc.html#SP1_2">&#167;1.2</a>, <a href="4-varc.html#SP5_1">&#167;5.1</a>, <a href="4-varc.html#SP10_1">&#167;10.1</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">SV_not_SN</span><span class="plain-syntax">, </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">A</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">B</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">R</span><span class="plain-syntax"> = </span><a href="4-varc.html#SP11" class="function-link"><span class="function-syntax">SPVerb::to_specification_inner</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">SV_not_SN</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="identifier-syntax">A</span><span class="plain-syntax">, </span><span class="identifier-syntax">B</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">R</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
<span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="function-syntax">SPVerb::to_specification_inner</span><span class="plain-syntax">(</span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">SV_not_SN</span><span class="plain-syntax">, </span><span class="identifier-syntax">wording</span><span class="plain-syntax"> </span><span class="identifier-syntax">W</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">A</span><span class="plain-syntax">, </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">B</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">spec</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">subject_noun_phrase</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, *</span><span class="identifier-syntax">verb_phrase</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">verb_usage</span><span class="plain-syntax"> *</span><span class="identifier-syntax">vu</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">verb_phrase_negated</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Node::is</span><span class="plain-syntax">(</span><span class="identifier-syntax">A</span><span class="plain-syntax">, </span><span class="identifier-syntax">AMBIGUITY_NT</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">amb</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">poss</span><span class="plain-syntax"> = </span><span class="identifier-syntax">A</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">; </span><span class="identifier-syntax">poss</span><span class="plain-syntax">; </span><span class="identifier-syntax">poss</span><span class="plain-syntax"> = </span><span class="identifier-syntax">poss</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">next_alternative</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">one</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::duplicate</span><span class="plain-syntax">(</span><span class="identifier-syntax">poss</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">one</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">next_alternative</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">new_poss</span><span class="plain-syntax"> = </span><a href="4-varc.html#SP11" class="function-link"><span class="function-syntax">SPVerb::to_specification</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">SV_not_SN</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="identifier-syntax">one</span><span class="plain-syntax">, </span><span class="identifier-syntax">B</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (!(</span><span class="identifier-syntax">Node::is</span><span class="plain-syntax">(</span><span class="identifier-syntax">new_poss</span><span class="plain-syntax">, </span><span class="identifier-syntax">UNKNOWN_NT</span><span class="plain-syntax">)))</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">amb</span><span class="plain-syntax"> = </span><span class="identifier-syntax">SyntaxTree::add_reading</span><span class="plain-syntax">(</span><span class="identifier-syntax">amb</span><span class="plain-syntax">, </span><span class="identifier-syntax">new_poss</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">amb</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="identifier-syntax">amb</span><span class="plain-syntax"> = </span><a href="2-spc.html#SP11" class="function-link"><span class="function-syntax">Specifications::new_UNKNOWN</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">amb</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">B</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">B</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">Node::is</span><span class="plain-syntax">(</span><span class="identifier-syntax">B</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">, </span><span class="identifier-syntax">AMBIGUITY_NT</span><span class="plain-syntax">))) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">amb</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">for</span><span class="plain-syntax"> (</span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">poss</span><span class="plain-syntax"> = </span><span class="identifier-syntax">B</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">; </span><span class="identifier-syntax">poss</span><span class="plain-syntax">; </span><span class="identifier-syntax">poss</span><span class="plain-syntax"> = </span><span class="identifier-syntax">poss</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">next_alternative</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">hmm</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::duplicate</span><span class="plain-syntax">(</span><span class="identifier-syntax">B</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">hmm</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::duplicate</span><span class="plain-syntax">(</span><span class="identifier-syntax">poss</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">hmm</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">next_alternative</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">new_poss</span><span class="plain-syntax"> = </span><a href="4-varc.html#SP11" class="function-link"><span class="function-syntax">SPVerb::to_specification</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">SV_not_SN</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="identifier-syntax">A</span><span class="plain-syntax">, </span><span class="identifier-syntax">hmm</span><span class="plain-syntax">);</span>
<span class="plain-syntax">            </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (!(</span><span class="identifier-syntax">Node::is</span><span class="plain-syntax">(</span><span class="identifier-syntax">new_poss</span><span class="plain-syntax">, </span><span class="identifier-syntax">UNKNOWN_NT</span><span class="plain-syntax">)))</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">amb</span><span class="plain-syntax"> = </span><span class="identifier-syntax">SyntaxTree::add_reading</span><span class="plain-syntax">(</span><span class="identifier-syntax">amb</span><span class="plain-syntax">, </span><span class="identifier-syntax">new_poss</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        }</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">amb</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="identifier-syntax">amb</span><span class="plain-syntax"> = </span><a href="2-spc.html#SP11" class="function-link"><span class="function-syntax">Specifications::new_UNKNOWN</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">amb</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="4-varc.html#SP11_1" class="named-paragraph-link"><span class="named-paragraph">Reconstruct a bare description as a sentence with an implied absent subject</span><span class="named-paragraph-number">11.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="4-varc.html#SP11_2" class="named-paragraph-link"><span class="named-paragraph">Check that the top structure of the tree is in order, and obtain the verb</span><span class="named-paragraph-number">11.2</span></a></span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">pcalc_term</span><span class="plain-syntax"> *</span><span class="identifier-syntax">subj</span><span class="plain-syntax"> = </span><span class="identifier-syntax">CREATE</span><span class="plain-syntax">(</span><span class="identifier-syntax">pcalc_term</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    *</span><span class="identifier-syntax">subj</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Terms::new_constant</span><span class="plain-syntax">(</span><span class="identifier-syntax">NULL</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">SV_not_SN</span><span class="plain-syntax">) </span><span class="named-paragraph-container code-font"><a href="4-varc.html#SP11_3" class="named-paragraph-link"><span class="named-paragraph">Convert an SV subtree</span><span class="named-paragraph-number">11.3</span></a></span>
<span class="plain-syntax">    </span><span class="reserved-syntax">else</span><span class="plain-syntax"> </span><span class="named-paragraph-container code-font"><a href="4-varc.html#SP11_4" class="named-paragraph-link"><span class="named-paragraph">Convert an SN subtree</span><span class="named-paragraph-number">11.4</span></a></span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><span class="identifier-syntax">spec</span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP11_1" class="paragraph-anchor"></a><b>&#167;11.1. </b>For instance, "if an open door" can contain a valid condition generating
an SV-subtree: the implied subject is whatever is being discussed (the I6 <span class="extract"><span class="extract-syntax">self</span></span>
object, in practice) and the implied verb is "is", in the present tense.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Reconstruct a bare description as a sentence with an implied absent subject</span><span class="named-paragraph-number">11.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">A</span><span class="plain-syntax">) &amp;&amp; (</span><span class="identifier-syntax">B</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">B</span><span class="plain-syntax"> = </span><a href="4-varc.html#SP3" class="function-link"><span class="function-syntax">SPVerb::marker</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">regular_to_be</span><span class="plain-syntax">, </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">, </span><span class="identifier-syntax">A</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">A</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::new</span><span class="plain-syntax">(</span><span class="identifier-syntax">UNKNOWN_NT</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">SV_not_SN</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><a href="4-varc.html#SP6" class="function-link"><span class="function-syntax">SPVerb::correct_for_adjectives</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">A</span><span class="plain-syntax">, </span><span class="identifier-syntax">B</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-varc.html#SP11">&#167;11</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP11_2" class="paragraph-anchor"></a><b>&#167;11.2. </b>Having performed that manoeuvre, we can be certain that the top of the tree
has the standard form, but we check it anyway.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Check that the top structure of the tree is in order, and obtain the verb</span><span class="named-paragraph-number">11.2</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">subject_noun_phrase</span><span class="plain-syntax"> = </span><span class="identifier-syntax">A</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">verb_phrase</span><span class="plain-syntax"> = </span><span class="identifier-syntax">B</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">verb_phrase</span><span class="plain-syntax">-&gt;</span><span class="identifier-syntax">down</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">StandardProblems::s_subtree_error</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="string-syntax">"VP childless"</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Node::get_type</span><span class="plain-syntax">(</span><span class="identifier-syntax">verb_phrase</span><span class="plain-syntax">) != </span><span class="identifier-syntax">UNKNOWN_NT</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">StandardProblems::s_subtree_error</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="string-syntax">"VP not a VP"</span><span class="plain-syntax">);</span>

<span class="plain-syntax">    </span><span class="identifier-syntax">vu</span><span class="plain-syntax"> = </span><span class="identifier-syntax">Node::get_verb</span><span class="plain-syntax">(</span><span class="identifier-syntax">verb_phrase</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">vu</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="identifier-syntax">StandardProblems::s_subtree_error</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="string-syntax">"verb null"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">verb_phrase_negated</span><span class="plain-syntax"> = (</span><span class="identifier-syntax">VerbUsages::is_used_negatively</span><span class="plain-syntax">(</span><span class="identifier-syntax">vu</span><span class="plain-syntax">))?</span><span class="identifier-syntax">TRUE:FALSE</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-varc.html#SP11">&#167;11</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP11_3" class="paragraph-anchor"></a><b>&#167;11.3. </b>There's a delicate little manoeuvre here. We have to be careful because
the tense and negation operators do not commute with each other: consider
the difference between "it was true that X is not Y" and "it is not true
that X was Y". It's therefore essential to apply these operators in the
correct order. What complicates this is that we have two ways to represent
the negation of an SV: "X is not Y" can be written as the negation operator
applied to "X is Y", which we'll call explicit negation, or as a direct
test of the proposition "not(X is Y)", which is implicit. Explicit negation
is essential if we need a non-present tense, because the tense operator
has to come between the negation operator and the test. So it might seem
that we should always use explicit negation. It makes no difference to
testing propositions, but it does make a difference to the "now" phrase,
because the asserting machinery can't take as wide a range of conditions
as the testing one: so, in general, a condition destined to be used in
a "now" must have implicit negation. Unfortunately, we can't know its
destiny yet. What saves the day is that "now" can only accept present
tense conditions anyway. We therefore adopt explicit negation only when
using a tense other than the present, and all is well.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Convert an SV subtree</span><span class="named-paragraph-number">11.3</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">pass</span><span class="plain-syntax"> = </span><span class="identifier-syntax">verb_phrase_negated</span><span class="plain-syntax">, </span><span class="identifier-syntax">explicit_negation</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> ((</span><span class="identifier-syntax">VerbUsages::is_used_negatively</span><span class="plain-syntax">(</span><span class="identifier-syntax">vu</span><span class="plain-syntax">)) &amp;&amp; (</span><span class="identifier-syntax">VerbUsages::get_tense_used</span><span class="plain-syntax">(</span><span class="identifier-syntax">vu</span><span class="plain-syntax">) != </span><span class="identifier-syntax">IS_TENSE</span><span class="plain-syntax">)) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">explicit_negation</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">; </span><span class="identifier-syntax">pass</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">spec</span><span class="plain-syntax"> = </span><a href="2-cnd.html#SP8" class="function-link"><span class="function-syntax">Conditions::new_TEST_PROPOSITION</span></a><span class="plain-syntax">(</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">SentencePropositions::S_subtree</span><span class="plain-syntax">(</span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="identifier-syntax">A</span><span class="plain-syntax">, </span><span class="identifier-syntax">B</span><span class="plain-syntax">, </span><span class="identifier-syntax">subj</span><span class="plain-syntax">, </span><span class="identifier-syntax">pass</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_subject_term</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">, </span><span class="identifier-syntax">subj</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Wordings::nonempty</span><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">)) </span><span class="identifier-syntax">Node::set_text</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">VerbUsages::get_tense_used</span><span class="plain-syntax">(</span><span class="identifier-syntax">vu</span><span class="plain-syntax">) != </span><span class="identifier-syntax">IS_TENSE</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">Binding::detect_locals</span><span class="plain-syntax">(</span><a href="2-spc.html#SP4" class="function-link"><span class="function-syntax">Specifications::to_proposition</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">), </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) &gt; </span><span class="constant-syntax">0</span><span class="plain-syntax">)</span>
<span class="plain-syntax">            </span><span class="named-paragraph-container code-font"><a href="4-varc.html#SP11_3_1" class="named-paragraph-link"><span class="named-paragraph">Issue a problem for referring to temporary values at a time when they did not exist</span><span class="named-paragraph-number">11.3.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">spec</span><span class="plain-syntax"> = </span><a href="2-cnd.html#SP10" class="function-link"><span class="function-syntax">Conditions::attach_tense</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">, </span><span class="identifier-syntax">VerbUsages::get_tense_used</span><span class="plain-syntax">(</span><span class="identifier-syntax">vu</span><span class="plain-syntax">));</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">explicit_negation</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">spec</span><span class="plain-syntax"> = </span><a href="2-cnd.html#SP7" class="function-link"><span class="function-syntax">Conditions::negate</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-varc.html#SP11">&#167;11</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP11_3_1" class="paragraph-anchor"></a><b>&#167;11.3.1. </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Issue a problem for referring to temporary values at a time when they did not exist</span><span class="named-paragraph-number">11.3.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">PM_DescLocalPast_location</span><span class="plain-syntax"> != </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax">)</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(), </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_DescLocalPast</span><span class="plain-syntax">),</span>
<span class="plain-syntax">            </span><span class="string-syntax">"conditions written in the past tense cannot refer to "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"temporary values"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="string-syntax">"because they have no past. For instance, the name given in a "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"'repeat...' can't be talked about as having existed before, and "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"similarly the pronoun 'it' changes its meaning often, so we can't "</span>
<span class="plain-syntax">            </span><span class="string-syntax">"safely talk about 'it' in the past."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">PM_DescLocalPast_location</span><span class="plain-syntax"> = </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax">;</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-varc.html#SP11_3">&#167;11.3</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP11_4" class="paragraph-anchor"></a><b>&#167;11.4. </b>This is easier, because tenses don't arise.
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Convert an SN subtree</span><span class="named-paragraph-number">11.4</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">spec</span><span class="plain-syntax"> = </span><a href="2-dsc.html#SP1" class="function-link"><span class="function-syntax">Descriptions::from_proposition</span></a><span class="plain-syntax">(</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">SentencePropositions::S_subtree</span><span class="plain-syntax">(</span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">, </span><span class="identifier-syntax">W</span><span class="plain-syntax">, </span><span class="identifier-syntax">A</span><span class="plain-syntax">, </span><span class="identifier-syntax">B</span><span class="plain-syntax">, </span><span class="identifier-syntax">subj</span><span class="plain-syntax">, </span><span class="identifier-syntax">verb_phrase_negated</span><span class="plain-syntax">), </span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Node::set_subject_term</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">, </span><span class="identifier-syntax">subj</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">Annotations::write_int</span><span class="plain-syntax">(</span><span class="identifier-syntax">spec</span><span class="plain-syntax">, </span><span class="identifier-syntax">converted_SN_ANNOT</span><span class="plain-syntax">, </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">A</span><span class="plain-syntax">) </span><span class="named-paragraph-container code-font"><a href="4-varc.html#SP11_4_1" class="named-paragraph-link"><span class="named-paragraph">Veto certain cases where text was misunderstood as a description</span><span class="named-paragraph-number">11.4.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">VerbUsages::get_tense_used</span><span class="plain-syntax">(</span><span class="identifier-syntax">vu</span><span class="plain-syntax">) != </span><span class="identifier-syntax">IS_TENSE</span><span class="plain-syntax">) </span><a href="4-varc.html#SP12" class="function-link"><span class="function-syntax">SPVerb::throw_past_problem</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-varc.html#SP11">&#167;11</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP11_4_1" class="paragraph-anchor"></a><b>&#167;11.4.1. </b>This is a little inelegant, but it catches awkward phrases such as "going
south in the Home" which might be read otherwise as "going south" (an action
pattern) plus "in the Home" (a description).
</p>

<p class="commentary"><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Veto certain cases where text was misunderstood as a description</span><span class="named-paragraph-number">11.4.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (!((</span><span class="identifier-syntax">Node::is</span><span class="plain-syntax">(</span><span class="identifier-syntax">A</span><span class="plain-syntax">, </span><span class="identifier-syntax">CONSTANT_NT</span><span class="plain-syntax">)) ||</span>
<span class="plain-syntax">        (</span><a href="2-spc.html#SP3" class="function-link"><span class="function-syntax">Specifications::is_description</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">A</span><span class="plain-syntax">)) ||</span>
<span class="plain-syntax">        (</span><a href="2-lvl.html#SP8" class="function-link"><span class="function-syntax">Lvalues::get_storage_form</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">A</span><span class="plain-syntax">) == </span><span class="identifier-syntax">LOCAL_VARIABLE_NT</span><span class="plain-syntax">) ||</span>
<span class="plain-syntax">        (</span><a href="2-lvl.html#SP8" class="function-link"><span class="function-syntax">Lvalues::get_storage_form</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">A</span><span class="plain-syntax">) == </span><span class="identifier-syntax">NONLOCAL_VARIABLE_NT</span><span class="plain-syntax">)))</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">return</span><span class="plain-syntax"> </span><a href="2-spc.html#SP11" class="function-link"><span class="function-syntax">Specifications::new_UNKNOWN</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">W</span><span class="plain-syntax">);</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-varc.html#SP11_4">&#167;11.4</a>.</li></ul>
<p class="commentary firstcommentary"><a id="SP12" class="paragraph-anchor"></a><b>&#167;12. </b></p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">SPVerb::throw_past_problem</span><button class="popup" onclick="togglePopup('usagePopup4')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup4">Usage of <span class="code-font"><span class="function-syntax">SPVerb::throw_past_problem</span></span>:<br/><a href="4-varc.html#SP11_4">&#167;11.4</a></span></button><span class="plain-syntax">(</span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">desc</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">PM_PastSubordinate_issued_at</span><span class="plain-syntax"> != </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">PM_PastSubordinate_issued_at</span><span class="plain-syntax"> = </span><span class="identifier-syntax">current_sentence</span><span class="plain-syntax">;</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">StandardProblems::sentence_problem</span><span class="plain-syntax">(</span><span class="identifier-syntax">Task::syntax_tree</span><span class="plain-syntax">(),</span>
<span class="plain-syntax">                </span><span class="identifier-syntax">_p_</span><span class="plain-syntax">(</span><span class="identifier-syntax">PM_PastSubordinate</span><span class="plain-syntax">),</span>
<span class="plain-syntax">                </span><span class="string-syntax">"subordinate clauses have to be in the present tense"</span><span class="plain-syntax">,</span>
<span class="plain-syntax">                </span><span class="string-syntax">"so 'the Black Door was open' is fine, but not 'something which "</span>
<span class="plain-syntax">                </span><span class="string-syntax">"was open'. Only the main verb can be in the past tense."</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP13" class="paragraph-anchor"></a><b>&#167;13. Internal test for sentence parsing.</b></p>

<pre class="displayed-code all-displayed-code code-font">
<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">SPVerb::perform_sentence_internal_test</span><button class="popup" onclick="togglePopup('usagePopup5')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup5">Usage of <span class="code-font"><span class="function-syntax">SPVerb::perform_sentence_internal_test</span></span>:<br/>Values Module - <a href="1-vm.html#SP2">&#167;2</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">OUTPUT_STREAM</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">internal_test_case</span><span class="plain-syntax"> *</span><span class="identifier-syntax">itc</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">SV_not_SN</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TRUE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="4-varc.html#SP13_1" class="named-paragraph-link"><span class="named-paragraph">Perform an internal test of the sentence converter</span><span class="named-paragraph-number">13.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>

<span class="reserved-syntax">void</span><span class="plain-syntax"> </span><span class="function-syntax">SPVerb::perform_description_internal_test</span><button class="popup" onclick="togglePopup('usagePopup6')"><span class="comment-syntax">?</span><span class="popuptext" id="usagePopup6">Usage of <span class="code-font"><span class="function-syntax">SPVerb::perform_description_internal_test</span></span>:<br/>Values Module - <a href="1-vm.html#SP2">&#167;2</a></span></button><span class="plain-syntax">(</span><span class="identifier-syntax">OUTPUT_STREAM</span><span class="plain-syntax">,</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">struct</span><span class="plain-syntax"> </span><span class="identifier-syntax">internal_test_case</span><span class="plain-syntax"> *</span><span class="identifier-syntax">itc</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">SV_not_SN</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="named-paragraph-container code-font"><a href="4-varc.html#SP13_1" class="named-paragraph-link"><span class="named-paragraph">Perform an internal test of the sentence converter</span><span class="named-paragraph-number">13.1</span></a></span><span class="plain-syntax">;</span>
<span class="plain-syntax">}</span>
</pre>
<p class="commentary firstcommentary"><a id="SP13_1" class="paragraph-anchor"></a><b>&#167;13.1. </b><span class="named-paragraph-container code-font"><span class="named-paragraph-defn">Perform an internal test of the sentence converter</span><span class="named-paragraph-number">13.1</span></span><span class="comment-syntax"> =</span>
</p>

<pre class="displayed-code all-displayed-code code-font">
<span class="plain-syntax">    </span><span class="identifier-syntax">parse_node</span><span class="plain-syntax"> *</span><span class="identifier-syntax">p</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="identifier-syntax">pcalc_prop</span><span class="plain-syntax"> *</span><span class="identifier-syntax">prop</span><span class="plain-syntax"> = </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">int</span><span class="plain-syntax"> </span><span class="identifier-syntax">tc</span><span class="plain-syntax"> = </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">;</span>

<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">SV_not_SN</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="function-syntax">&lt;s-sentence&gt;(itc-&gt;</span><span class="identifier-syntax">text_supplying_the_case</span><span class="plain-syntax">)) </span><span class="identifier-syntax">p</span><span class="plain-syntax"> = </span><span class="function-syntax">&lt;&lt;rp&gt;&gt;</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    } </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="function-syntax">&lt;s-descriptive-np&gt;(itc-&gt;</span><span class="identifier-syntax">text_supplying_the_case</span><span class="plain-syntax">)) </span><span class="identifier-syntax">p</span><span class="plain-syntax"> = </span><span class="function-syntax">&lt;&lt;rp&gt;&gt;</span><span class="plain-syntax">;</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">p</span><span class="plain-syntax">) {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">prop</span><span class="plain-syntax"> = </span><a href="2-spc.html#SP4" class="function-link"><span class="function-syntax">Specifications::to_proposition</span></a><span class="plain-syntax">(</span><span class="identifier-syntax">p</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">tc</span><span class="plain-syntax"> = </span><span class="identifier-syntax">TypecheckPropositions::type_check</span><span class="plain-syntax">(</span><span class="identifier-syntax">prop</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">TypecheckPropositions::tc_no_problem_reporting</span><span class="plain-syntax">());</span>
<span class="plain-syntax">    }</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">p</span><span class="plain-syntax"> == </span><span class="identifier-syntax">NULL</span><span class="plain-syntax">) </span><span class="identifier-syntax">LOG</span><span class="plain-syntax">(</span><span class="string-syntax">"Failed: not a condition"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">    </span><span class="reserved-syntax">else</span><span class="plain-syntax"> {</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">LOG</span><span class="plain-syntax">(</span><span class="string-syntax">"$D\n"</span><span class="plain-syntax">, </span><span class="identifier-syntax">prop</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="reserved-syntax">if</span><span class="plain-syntax"> (</span><span class="identifier-syntax">tc</span><span class="plain-syntax"> == </span><span class="identifier-syntax">FALSE</span><span class="plain-syntax">) </span><span class="identifier-syntax">LOG</span><span class="plain-syntax">(</span><span class="string-syntax">"Failed: proposition would not type-check\n"</span><span class="plain-syntax">);</span>
<span class="plain-syntax">        </span><span class="identifier-syntax">TypecheckPropositions::type_check</span><span class="plain-syntax">(</span><span class="identifier-syntax">prop</span><span class="plain-syntax">,</span>
<span class="plain-syntax">            </span><span class="identifier-syntax">TypecheckPropositions::tc_problem_logging</span><span class="plain-syntax">());</span>
<span class="plain-syntax">    }</span>
</pre>
<ul class="endnotetexts"><li>This code is used in <a href="4-varc.html#SP13">&#167;13</a> (twice).</li></ul>
<nav role="progress"><div class="progresscontainer">
    <ul class="progressbar"><li class="progressprev"><a href="4-teav.html">&#10094;</a></li><li class="progresschapter"><a href="P-wtmd.html">P</a></li><li class="progresschapter"><a href="1-vm.html">1</a></li><li class="progresschapter"><a href="2-spc.html">2</a></li><li class="progresschapter"><a href="3-pl.html">3</a></li><li class="progresscurrentchapter">4</li><li class="progresssection"><a href="4-ets.html">ets</a></li><li class="progresssection"><a href="4-cad.html">cad</a></li><li class="progresssection"><a href="4-teav.html">teav</a></li><li class="progresscurrent">varc</li><li class="progresssection"><a href="4-cap.html">cap</a></li><li class="progresssection"><a href="4-il.html">il</a></li><li class="progresssection"><a href="4-inv.html">inv</a></li><li class="progresssection"><a href="4-pi.html">pi</a></li><li class="progresschapter"><a href="5-dsh.html">5</a></li><li class="progressnext"><a href="4-cap.html">&#10095;</a></li></ul></div>
</nav><!-- End of weave -->

		</main>
	</body>
</html>

