
Language "C" {
	Details: "The C programming language"
	Extension: ".c"
	Multiline Comment Open: "/*"
	Multiline Comment Close: "*/"
	Line Comment: "//"
	String Literal: "\""
	String Literal Escape: "\\"
	Character Literal: "'"
	Character Literal Escape: "\\"
	C-Like: true
	
	// C does in fact support octal literals, marking them as starting with an
	// unnecessary initial zero. This is practically obsolete now, and in any case
	// makes no difference to syntax-colouring. Binary literals were in theory
	// rejected by the C standards body as useless, but are so useful that gcc
	// and clang support them anyway.
	
	Hexadecimal Literal Prefix: "0x"
	Binary Literal Prefix: "0b"
	Negative Literal Prefix: "-"
	
	Before Named Paragraph Expansion: "\n{\n"
	After Named Paragraph Expansion: "}\n"
	Start Ifdef: "#ifdef %S\n"
	End Ifdef: "#endif /* %S */\n"
	Start Ifndef: "#ifndef %S\n"
	End Ifndef: "#endif /* %S */\n"
	Line Marker: "#line %d \"%f\"\n"
	
	Start Definition: "#define %S\s"
	Prolong Definition: "\\\n\s\s\s\s"
	End Definition: "\n"
	
	keyword auto
	keyword break
	keyword case
	keyword char
	keyword const
	keyword continue
	keyword default
	keyword do
	keyword double
	keyword else
	keyword enum
	keyword extern
	keyword float
	keyword for
	keyword goto
	keyword if
	keyword int
	keyword long
	keyword register
	keyword return
	keyword short
	keyword signed
	keyword sizeof
	keyword static
	keyword struct
	keyword switch
	keyword typedef
	keyword union
	keyword unsigned
	keyword void
	keyword volatile
	keyword while
	
	colouring {
		runs of unquoted {
			runs of !identifier {
				keyword of !reserved => !reserved
				keyword of !function => !function
				keyword of !constant => !constant
				keyword of !element => {
					optionally spaced prefix . => !element
					optionally spaced prefix -> => !element
				}
			}
		}
	}
}

Language "code" {
	Details: "For quoting generic code samples."
	Extension: ".txt"
	
	colouring {
		=> !identifier
	}
}

Language "InC" {
	Details: "The Inform-tools extension to the C programming language"
	Extension: ".c"
	Supports Namespaces: true
	Multiline Comment Open: "/*"
	Multiline Comment Close: "*/"
	Line Comment: "//"
	String Literal: "\""
	String Literal Escape: "\\"
	Character Literal: "'"
	Character Literal Escape: "\\"
	C-Like: true
	
	// C does in fact support octal literals, marking them as starting with an
	// unnecessary initial zero. This is practically obsolete now, and in any case
	// makes no difference to syntax-colouring. Binary literals were in theory
	// rejected by the C standards body as useless, but are so useful that gcc
	// and clang support them anyway.
	
	Hexadecimal Literal Prefix: "0x"
	Binary Literal Prefix: "0b"
	Negative Literal Prefix: "-"
	
	// The "shebang" routine for a language is called to add anything it wants to
	// at the very top of the tangled code. (For a scripting language such as
	// Perl or Python, that might be a shebang: "hence the name.)"
	// But we will use it to defime the constant PLATFORM_POSIX everywhere except
	// Windows. This needs to happen right at the top, because the "very early
	// code" in a tangle may contain material conditional on whether it is defined.
	
	Shebang: "#ifndef PLATFORM_WINDOWS\n#define PLATFORM_POSIX\n#endif\n"
	Before Named Paragraph Expansion: "\n{\n"
	After Named Paragraph Expansion: "}\n"
	Start Ifdef: "#ifdef %S\n"
	End Ifdef: "#endif /* %S */\n"
	Start Ifndef: "#ifndef %S\n"
	End Ifndef: "#endif /* %S */\n"
	Line Marker: "#line %d \"%f\"\n"
	Start Definition: "#define %S\s"
	Prolong Definition: "\\\n\s\s\s\s"
	End Definition: "\n"
	
	// FILE gets in even though it's not technically reserved but only a type
	// name, defined in the standard C library.
	
	keyword FILE
	
	keyword auto
	keyword break
	keyword case
	keyword char
	keyword const
	keyword continue
	keyword default
	keyword do
	keyword double
	keyword else
	keyword enum
	keyword extern
	keyword float
	keyword for
	keyword goto
	keyword if
	keyword int
	keyword long
	keyword register
	keyword return
	keyword short
	keyword signed
	keyword sizeof
	keyword static
	keyword struct
	keyword switch
	keyword typedef
	keyword union
	keyword unsigned
	keyword void
	keyword volatile
	keyword while
	
	colouring {
		runs of unquoted {
			runs of !identifier {
				keyword of !reserved => !reserved
				keyword of !function => !function
				keyword of !constant => !constant
				keyword of !element => {
					optionally spaced prefix . => !element
					optionally spaced prefix -> => !element
				}
			}
			matches of /<\S+>/ {
				=> !function
			}
		}
	}
}

Language "Inform 6" {
	Details: "The C-like interactive fiction language Inform 6"
	Extension: ".i6"
	Line Comment: "!"
	String Literal: "\""
	Character Literal: "'"
	Binary Literal Prefix: "$$"
	Hexadecimal Literal Prefix: "$"
	Negative Literal Prefix: "-"
	
	Start Definition: "Constant %S =\s"
	End Definition: ";\n"
	
	Start Ifdef: "#ifdef %S;\n"
	End Ifdef: "#endif; ! %S\n"
	Start Ifndef: "#ifndef %S;\n"
	End Ifndef: "#endif; ! %S\n"
	
	// Reserved words:
	
	keyword "Constant"
	keyword "Array"
	
	keyword "box"
	keyword "break"
	keyword "child"
	keyword "children"
	keyword "continue"
	keyword "default"
	keyword "do"
	keyword "elder"
	keyword "eldest"
	keyword "else"
	keyword "false"
	keyword "font"
	keyword "for"
	keyword "give"
	keyword "has"
	keyword "hasnt"
	keyword "if"
	keyword "in"
	keyword "indirect"
	keyword "inversion"
	keyword "jump"
	keyword "metaclass"
	keyword "move"
	keyword "new_line"
	keyword "nothing"
	keyword "notin"
	keyword "objectloop"
	keyword "ofclass"
	keyword "or"
	keyword "parent"
	keyword "print"
	keyword "print_ret"
	keyword "provides"
	keyword "quit"
	keyword "random"
	keyword "read"
	keyword "remove"
	keyword "restore"
	keyword "return"
	keyword "rfalse"
	keyword "rtrue"
	keyword "save"
	keyword "sibling"
	keyword "spaces"
	keyword "string"
	keyword "style"
	keyword "switch"
	keyword "to"
	keyword "true"
	keyword "until"
	keyword "while"
	keyword "younger"
	keyword "youngest"
	
	colouring {
		runs of unquoted {
			runs of !identifier {
				keyword of !reserved => !reserved
				keyword of !function => !function
				keyword of !constant => !constant
				keyword of !element => {
					optionally spaced prefix . => !element
					optionally spaced prefix -> => !element
				}
			}
		}
	}
}

Language "Inform 7" {
	Details: "The natural-language based language Inform 7"
	Extension: ".i7x"
	Multiline Comment Open: "["
	Multiline Comment Close: "]"
	String Literal: "\""
	
	// This is here so that tangling the Standard Rules extension doesn't insert
	// a spurious comment betraying Inweb's involvement in the process -
	
	Suppress Disclaimer: true
	
	colouring {
		runs of unquoted {
			matches of /\aSection .*?\z/ {
				=> !heading
			}
			matches of /\aChapter .*?\z/ {
				=> !heading
			}
			matches of /\aVolume .*?\z/ {
				=> !heading
			}
			matches of /\aBook .*?\z/ {
				=> !heading
			}
			matches of /\aPart .*?\z/ {
				=> !heading
			}
			matches of /\a\s*->.*?\z/ {
				=> !function
			}
			matches of /\a\s*<-.*?\z/ {
				=> !function
			}
			matches of /\a\(.*?\.\) *\z/ {
				=> !function
			}
		}
	}
}

Language "None" {
	Details: "For programs in languages not yet supported by Inweb"
	Extension: ".txt"
}

Language "problems" {
	Details: "For styling problem messages output by Inform"
	Extension: ".txt"
	
	colouring {
		=> !identifier
		brackets in /\s*(>)(.*)/ {
			number 1 => !element
			number 2 => !extract
		}
	}
}

Language "text" {
	Details: "For text files which are not programs"
	Extension: ".txt"
	
	colouring {
		=> !plain
	}
}

Language "transcript" {
	Details: "For styling transcripts of story file output"
	Extension: ".txt"
	
	colouring {
		=> !identifier
		brackets in /\s*(>)(.*)/ {
			number 1 => !element
			number 2 => !extract
		}
	}
}
